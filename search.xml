<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[自动化构建工具-gulp学习]]></title>
      <url>%2Fposts%2F41524%2F</url>
      <content type="text"><![CDATA[gulp是什么？gulp是前端开发过程中对代码进行构建的工具，是基于Nodejs的自动任务运行器，能自动化地完成 javascript/coffee/sass/less/html/image/css 等文件的的测试、检查、合并、压缩、格式化、浏览器自动刷新、部署文件生成，并监听文件在改动后重复指定的这些步骤。使用gulp将大大提升开发效率。 gulp的使用安装gulp是基于node.js的，首先要安装好node.js，目前最新稳定版已经是6.9.5了。安装好之后使用npm工具，全局安装gulp1npm install gulp -g 显示安装完毕后查看是否正确，在命令行输入gulp -v，出现版本号即为正确安装。 新建package.json文件12345678910111213141516171819&#123; "name": "test", //项目名称（必须） "version": "1.0.0", //项目版本（必须） "description": "This is for study gulp project !", //项目描述（必须） "homepage": "", //项目主页 "repository": &#123; //项目资源库 "type": "git", "url": "https://git.lamb2014" &#125;, "author": &#123; //项目作者信息 "name": "lamb2014", "email": "lamb2014@hoxmail.com" &#125;, "license": "ISC", //项目许可协议 "devDependencies": &#123; //项目依赖的插件 "gulp": "^3.9.1", "gulp-less": "^3.3.0" &#125;&#125; 注意package.json是一个普通json文件，上例中只是为了方便查看，实际中不能添加任何注释！ 本地安装gulp插件为了能正常使用，还得本地安装gulp，npm install gulp –save-dev这里要记录下–save-dev和–save的区别：–save-dev命令是安装开发环境所需依赖，安装包信息将会写入package.json文件中的devDependencies(开发依赖)里面，例如gulp只是方便我们在开发时使用，到生产环境中并不需要，所以使用–save-dev命令，而像常用的jquery,vue等，实际上线后仍然需要，就写入到dependencies。 创建gulpfile.js文件gulpfile.js是gulp项目的配置文件12345678910111213141516//导入工具包 require('node_modules里对应模块')var gulp = require('gulp'), //本地安装gulp所用到的地方 less = require('gulp-less'); //定义一个testLess任务（自定义任务名称）gulp.task('testLess', function () &#123; gulp.src('src/less/index.less') //该任务针对的文件 .pipe(less()) //该任务调用的模块 .pipe(gulp.dest('src/css')); //将会在src/css下生成index.css&#125;); gulp.task('default',['testLess', 'elseTask']); //定义默认任务 elseTask为其他任务，该示例没有定义elseTask任务 //gulp.task(name[, deps], fn) 定义任务 name：任务名称 deps：依赖任务名称 fn：回调函数//gulp.src(globs[, options]) 执行任务处理的文件 globs：处理的文件路径(字符串或者字符串数组) //gulp.dest(path[, options]) 处理完后文件生成路径 运行gulp命令行输入gulp将会调用default任务里的所有任务[‘testLess’,’elseTask’]。也可以gulp+任务名运行。 gulp+Browsersync实现实时更新BrowsersyncBrowsersync概念与安装Browsersync是一个非常强大有用的工具，能让浏览器实时、快速响应您的文件更改（html、js、css、sass、less等）并自动刷新页面。还可以同时在PC、平板、手机等设备下进项调试。使用browsersync后，任何一次代码修改保存，所有设备都会同时显示改动。BrowserSync也是基于Node.js的, 是一个Node模块，可直接通过npm安装。全局安装Browsersync1npm install -g browser-sync 启动 Browsersync静态网站如果要监听本地的项目的.html文件，可以先进入到项目在命令行运行以下命令1browser-sync start --server --files &quot;**/*.html&quot; 也可以监听多个类型的文件，只需要用逗号隔开，直接写”**”监听项目所有文件变化1browser-sync start --server --files &quot;**/*.css, **/*.html&quot; 如图所示Browsersync会启用3000和3001两个端口，并自动在浏览器跳转到localhost:3000端口，下面一个则是本地ip加上端口号，在手机上直接输入这个ip+端口地址就可以测试了，非常高效。这时在更改里面的文件时浏览器会自动刷新更新。 动态网站如果项目是运行在本地服务器里，那就需要使用代理模式12// 主机名可以是ip或域名browser-sync start --proxy &quot;主机名&quot; &quot;css/*.css&quot; gulp+Browsersync本地安装Browsersync：$ npm install browser-sync –save-dev在gulpfile.js 文件里使用123456789101112131415161718var gulp = require('gulp');var browserSync = require('browser-sync').create();// 静态服务器gulp.task('browser-sync', function() &#123; browserSync.init(&#123; server: &#123; baseDir: "./" &#125; &#125;);&#125;);// 代理gulp.task('browser-sync', function() &#123; browserSync.init(&#123; proxy: "域名或IP" &#125;);&#125;); 直接在项目目录下命令行执行gulp即可]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[vue.js学习(四)]]></title>
      <url>%2Fposts%2F4806%2F</url>
      <content type="text"><![CDATA[过渡效果Vue 在插入、更新或者移除 DOM 时，提供多种不同方式的应用过渡效果。包括以下工具：1.在 CSS 过渡和动画中自动应用 class2.可以配合使用第三方 CSS 动画库，如 Animate.css3.在过渡钩子函数中使用 JavaScript 直接操作 DOM4.可以配合使用第三方 JavaScript 动画库，如 Velocity.js 单元素/组件的过渡Vue 提供了 transition 的封装组件，在下列情形中，可以给任何元素和组件添加 entering/leaving 过渡条件渲染 （使用 v-if）条件展示 （使用 v-show）动态组件组件根节点123456789//html&lt;div id="demo"&gt; &lt;button v-on:click="show = !show"&gt; Toggle &lt;/button&gt; &lt;transition name="fade"&gt; &lt;p v-if="show"&gt;hello&lt;/p&gt; &lt;/transition&gt;&lt;/div&gt; 1234567//jsnew Vue(&#123; el: '#demo', data: &#123; show: true &#125;&#125;) 1234567//css.fade-enter-active, .fade-leave-active &#123; transition: opacity .5s&#125;.fade-enter, .fade-leave-active &#123; opacity: 0&#125; 这个例子中v-on绑定一个简单的点击事件来更改p的dom状态，再通过vue.js的过渡css类名形成一个简单的动画效果 过渡的css类名有 4 个(CSS)类名在 enter/leave 的过渡中切换：1.v-enter: 定义进入过渡的开始状态。在元素被插入时生效，在下一个帧移除。2.v-enter-active: 定义进入过渡的结束状态。在元素被插入时生效，在 transition/animation 完成之后移除。3.v-leave: 定义离开过渡的开始状态。在离开过渡被触发时生效，在下一个帧移除。4.v-leave-active: 定义离开过渡的结束状态。在离开过渡被触发时生效，在 transition/animation 完成之后移除。对于这些在 enter/leave 过渡中切换的类名，v- 是这些类名的前缀。使用 &lt;transition name=”my-transition”&gt; 可以重置前缀，比如 v-enter 替换为 my-transition-enter。 自定义过渡类名可以通过以下特性来自定义过渡类名：enter-classenter-active-classleave-classleave-active-class们的优先级高于普通的类名，这对于 Vue 的过渡系统和其他第三方 CSS 动画库，如 Animate.css 结合使用十分有用。1234567891011121314151617181920&lt;link href="css/animate.min.css" rel="stylesheet" type="text/css"&gt;&lt;div id="example-3"&gt; &lt;button @click="show = !show"&gt; Toggle render &lt;/button&gt; &lt;transition name="custom-classes-transition" enter-active-class="animated tada" leave-active-class="animated bounceOutRight" &gt; &lt;p v-if="show"&gt;hello&lt;/p&gt; &lt;/transition&gt;&lt;/div&gt;//jsnew Vue(&#123; el: '#example-3', data: &#123; show: true &#125;&#125;) 多个组件的过渡多个组件的过渡只需要使用动态组件1234//html&lt;transition name="component-fade" mode="out-in"&gt; &lt;component v-bind:is="view"&gt;&lt;/component&gt;&lt;/transition&gt; 123456789101112131415//jsnew Vue(&#123; el: '#transition-components-demo', data: &#123; view: 'v-a' &#125;, components: &#123; 'v-a': &#123; template: '&lt;div&gt;Component A&lt;/div&gt;' &#125;, 'v-b': &#123; template: '&lt;div&gt;Component B&lt;/div&gt;' &#125; &#125;&#125;) 1234567//css.component-fade-enter-active, .component-fade-leave-active &#123; transition: opacity .3s ease;&#125;.component-fade-enter, .component-fade-leave-active &#123; opacity: 0;&#125; 列表过渡列表过渡使用 &lt;transition-group&gt; 组件12345678910//html&lt;div id="list-demo" class="demo"&gt; &lt;button v-on:click="add"&gt;Add&lt;/button&gt; &lt;button v-on:click="remove"&gt;Remove&lt;/button&gt; &lt;transition-group name="list" tag="p"&gt; &lt;span v-for="item in items" v-bind:key="item" class="list-item"&gt; &#123;&#123; item &#125;&#125; &lt;/span&gt; &lt;/transition-group&gt;&lt;/div&gt; 12345678910111213141516171819//jsnew Vue(&#123; el: '#list-demo', data: &#123; items: [1,2,3,4,5,6,7,8,9], nextNum: 10 &#125;, methods: &#123; randomIndex: function () &#123; return Math.floor(Math.random() * this.items.length) &#125;, add: function () &#123; this.items.splice(this.randomIndex(), 0, this.nextNum++) &#125;, remove: function () &#123; this.items.splice(this.randomIndex(), 1) &#125;, &#125;&#125;) 123456789101112//css.list-item &#123; display: inline-block; margin-right: 10px;&#125;.list-enter-active, .list-leave-active &#123; transition: all 1s;&#125;.list-enter, .list-leave-active &#123; opacity: 0; transform: translateY(30px);&#125; 上面代码button绑定一个add一个remove事件，通过transition-group达到添加删除时的过渡效果。注意：1.不同于 &lt;transition&gt;， 它会以一个真实元素呈现：默认为一个 &lt;span&gt;。也可以通过 tag 特性更换为其他元素.上面代码指定的是p。2.元素 一定需要 指定唯一的 key 特性值。 可复用的过渡过渡可以通过 Vue 的组件系统实现复用。要创建一个可复用过渡组件，需要将 &lt;transition&gt; 或者 &lt;transition-group&gt;作为根组件，然后将任何子组件放置在其中就可以了。1234567891011121314151617181920Vue.component('my-special-transition', &#123; template: '\ &lt;transition\ name="very-special-transition"\ mode="out-in"\ v-on:before-enter="beforeEnter"\ v-on:after-enter="afterEnter"\ &gt;\ &lt;slot&gt;&lt;/slot&gt;\ &lt;/transition&gt;\ ', methods: &#123; beforeEnter: function (el) &#123; // ... &#125;, afterEnter: function (el) &#123; // ... &#125; &#125;&#125;)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[es6新特性(五)]]></title>
      <url>%2Fposts%2F38030%2F</url>
      <content type="text"><![CDATA[PromisePromise的概念Promise是异步编程的一种解决方案。从语法上说，Promise是一个对象，从它可以获取异步操作的消息。Promise提供统一的API，各种异步操作都可以用同样的方法进行处理。Promise对象代表一个异步操作，有三种状态：Pending（进行中）、Resolved（已完成，又称Fulfilled）和Rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。Promise对象的状态改变，只有两种可能：从Pending变为Resolved和从Pending变为Rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果。就算改变已经发生了，你再对Promise对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。有了Promise对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。 Promise基本用法Promise对象是一个构造函数，用来生成Promise实例。12345678var promise = new Promise(function(resolve, reject) &#123; // ... some code if (/* 异步操作成功 */)&#123; resolve(value); &#125; else &#123; reject(error); &#125;&#125;); Promise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject。resolve函数的作用是，将Promise对象的状态从“未完成”变为“成功”（即从Pending变为Resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；reject函数的作用是，将Promise对象的状态从“未完成”变为“失败”（即从Pending变为Rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。Promise实例生成以后，可以用then方法分别指定Resolved状态和Reject状态的回调函数。12345promise.then(function(value) &#123; // success&#125;, function(error) &#123; // failure&#125;); then方法可以接受两个回调函数作为参数。第一个回调函数是Promise对象的状态变为Resolved时调用，第二个回调函数是Promise对象的状态变为Reject时调用。其中，第二个函数是可选的，不一定要提供。这两个函数都接受Promise对象传出的值作为参数。1234567891011let promise = new Promise(function(resolve, reject) &#123; console.log('Promise'); resolve();&#125;);promise.then(function() &#123; console.log('Resolved.');&#125;);console.log('Hi!');// Promise// Hi!// Resolved 上面代码中，Promise新建后立即执行，所以首先输出的是“Promise”。然后，then方法指定的回调函数，将在当前脚本所有同步任务执行完才会执行，所以“Resolved”最后输出。如果调用resolve函数和reject函数时带有参数，那么它们的参数会被传递给回调函数。reject函数的参数通常是Error对象的实例，表示抛出的错误；resolve函数的参数除了正常的值以外，还可能是另一个Promise实例，表示异步操作的结果有可能是一个值，也有可能是另一个异步操作，比如像下面这样。1234567var p1 = new Promise(function (resolve, reject) &#123; // ...&#125;);var p2 = new Promise(function (resolve, reject) &#123; // ... resolve(p1);&#125;) 上面代码中，p1和p2都是Promise的实例，但是p2的resolve方法将p1作为参数，即一个异步操作的结果是返回另一个异步操作。注意，这时p1的状态就会传递给p2，也就是说，p1的状态决定了p2的状态。如果p1的状态是Pending，那么p2的回调函数就会等待p1的状态改变；如果p1的状态已经是Resolved或者Rejected，那么p2的回调函数将会立刻执行。 thenromise实例具有then方法，它的作用是为Promise实例添加状态改变时的回调函数。then方法的第一个参数是Resolved状态的回调函数，第二个参数（可选）是Rejected状态的回调函数。then方法返回的是一个新的Promise实例。因此可以采用链式写法，即then方法后面再调用另一个then方法。12345getJSON("/posts.json").then(function(json) &#123; return json.post;&#125;).then(function(post) &#123; // ...&#125;); 上面的代码使用then方法，依次指定了两个回调函数。第一个回调函数完成以后，会将返回结果作为参数，传入第二个回调函数。采用链式的then，可以指定一组按照次序调用的回调函数。这时，前一个回调函数，有可能返回的还是一个Promise对象（即有异步操作），这时后一个回调函数，就会等待该Promise对象的状态发生变化，才会被调用。 catchcatch方法是.then(null, rejection)的别名，用于指定发生错误时的回调函数。123456getJSON("/posts.json").then(function(posts) &#123; // ...&#125;).catch(function(error) &#123; // 处理 getJSON 和 前一个回调函数运行时发生的错误 console.log('发生错误！', error);&#125;); 上面代码中，getJSON方法返回一个Promise对象，如果该对象状态变为Resolved，则会调用then方法指定的回调函数；如果异步操作抛出错误，状态就会变为Rejected，就会调用catch方法指定的回调函数，处理这个错误。另外，then方法指定的回调函数，如果运行中抛出错误，也会被catch方法捕获。如果Promise状态已经变成Resolved，再抛出错误是无效的。Promise对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止。也就是说，错误总是会被下一个catch语句捕获。1234567getJSON("/post/1.json").then(function(post) &#123; return getJSON(post.commentURL);&#125;).then(function(comments) &#123; // some code&#125;).catch(function(error) &#123; // 处理前面三个Promise产生的错误&#125;); 上面代码中，一共有三个Promise对象：一个由getJSON产生，两个由then产生。它们之中任何一个抛出的错误，都会被最后一个catch捕获。注意!catch方法返回的还是一个 Promise 对象，因此后面还可以接着调用then方法。123456789101112131415var someAsyncThing = function() &#123; return new Promise(function(resolve, reject) &#123; // 下面一行会报错，因为x没有声明 resolve(x + 2); &#125;);&#125;;someAsyncThing().catch(function(error) &#123; console.log('oh no', error);&#125;).then(function() &#123; console.log('carry on');&#125;);// oh no [ReferenceError: x is not defined]// carry on 上面代码运行完catch方法指定的回调函数，会接着运行后面那个then方法指定的回调函数。如果没有报错，则会跳过catch方法。catch方法之中，还能再抛出错误。1234567891011121314151617var someAsyncThing = function() &#123; return new Promise(function(resolve, reject) &#123; // 下面一行会报错，因为x没有声明 resolve(x + 2); &#125;);&#125;;someAsyncThing().then(function() &#123; return someOtherAsyncThing();&#125;).catch(function(error) &#123; console.log('oh no', error); // 下面一行会报错，因为y没有声明 y + 2;&#125;).catch(function(error) &#123; console.log('carry on', error);&#125;);// oh no [ReferenceError: x is not defined]// carry on [ReferenceError: y is not defined] 上例中第二个catch方法用来捕获，前一个catch方法抛出的错误。 Promise.all()Promise.all方法用于将多个Promise实例1var p = Promise.all([p1, p2, p3]); 上例中，Promise.all方法接受一个数组作为参数，p1、p2、p3都是Promise对象的实例，如果不是，就会先调用下面讲到的Promise.resolve方法，将参数转为Promise实例，再进一步处理。注意！Promise.all方法的参数可以不是数组，但必须具有Iterator接口，且返回的每个成员都是Promise实例。12345678910const databasePromise = connectDatabase();const booksPromise = databaseProimse .then(findAllBooks);const userPromise = databasePromise .then(getCurrentUser);Promise.all([ booksPromise, userPromise]).then(([books, user]) =&gt; pickTopRecommentations(books, user)); 上例中booksPromise和userPromise是两个异步操作，只有等到它们的结果都返回了，才会触发pickTopRecommentations这个回调函数。 Promise.resolve()Promise.resolve方法是将现有对象转为Promise对象。1var jsPromise = Promise.resolve($.ajax('/whatever.json')); 上面代码将jQuery生成的deferred对象，转为一个新的Promise对象。Promise.resolve方法的参数分成四种情况。（1）参数是一个Promise实例Promise.resolve将不做任何修改、原封不动地返回这个实例。（2）参数是一个thenable对象thenable对象指的是具有then方法的对象123456789let thenable = &#123; then: function(resolve, reject) &#123; resolve(42); &#125;&#125;;let p1 = Promise.resolve(thenable);p1.then(function(value) &#123; console.log(value); // 42&#125;); thenable对象的then方法执行后，对象p1的状态就变为resolved，从而立即执行最后那个then方法指定的回调函数，输出42。（3）参数不是具有then方法的对象，或根本就不是对象在这种情况下Promise.resolve方法返回一个新的Promise对象，状态为Resolved。12345var p = Promise.resolve('Hello');p.then(function (s)&#123; console.log(s)&#125;);// Hello 上例中生成一个新的Promise对象的实例p。由于字符串Hello不属于异步操作（判断方法是它不是具有then方法的对象），返回Promise实例的状态从一生成就是Resolved，所以回调函数会立即执行。Promise.resolve方法的参数，会同时传给回调函数。（4）不带有任何参数Promise.resolve方法允许调用时不带参数，直接返回一个Resolved状态的Promise对象。如果希望得到一个Promise对象，比较方便的方法就是直接调用Promise.resolve方法。1234var p = Promise.resolve();p.then(function () &#123; // ...&#125;); 上面代码的变量p就是一个Promise对象。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[vue.js学习（三）]]></title>
      <url>%2Fposts%2F62033%2F</url>
      <content type="text"><![CDATA[计算属性基本用法计算属性用于处理一些复杂逻辑，关键词是computed12345678910111213141516171819&lt;div id="app"&gt; &lt;p&gt;原始字符串: &#123;&#123; message &#125;&#125;&lt;/p&gt; &lt;p&gt;计算后反转字符串: &#123;&#123; reversedMessage &#125;&#125;&lt;/p&gt;&lt;/div&gt; &lt;script&gt;var vm = new Vue(&#123; el: '#app', data: &#123; message: 'come on!' &#125;, computed: &#123; // 计算属性的 getter reversedMessage: function () &#123; // `this` 指向 vm 实例 return this.message.split('').reverse().join('') &#125; &#125;&#125;)&lt;/script&gt; 这个例子声明了一个计算属性reversedMessage，提供的函数将用作属性vm.reversedMessage的值（官方文档叫做getter）。vm.reversedMessage依赖于vm.message，在vm.message发生改变时，vm.reversedMessage也会更新。这意味这能像绑定普通属性一样在模板中绑定计算属性。 computed vs methods将上例中的computed改成methods,也可以达到一样的效果，但两者有区别，计算属性根据它的依赖被缓存，如果 message 没有被修改，多次访问 reversedMessage 计算属性会立即返回之前的计算结果，不必再次执行函数，而 method 则每次调用都会重新计算。 计算setter默认情况下，计算属性只有一个 getter，也可以给它加上 setter：1234567891011121314151617181920&lt;div id="demo"&gt;&#123;&#123; fullName &#125;&#125;&lt;/div&gt;&lt;script&gt;var vm = new Vue(&#123; el:'#demo', computed: &#123; fullName: &#123; // getter get: function () &#123; return this.firstName + ' ' + this.lastName &#125;, // setter set: function (newValue) &#123; var names = newValue.split(' ') this.firstName = names[0] this.lastName = names[names.length - 1] &#125; &#125; &#125;&#125;)&lt;/script&gt; 现在在运行 vm.fullName = ‘Lamb le’ 时， setter 会被调用， vm.firstName 和 vm.lastName 也会被对应更新。 组件组件（Component）是 Vue.js 最强大的功能之一。组件可以扩展 HTML 元素，封装可重用的代码。通俗来讲就是页面由多个块组成，每个块可以写一个组件，然后通过vue.js引用。 使用组件注册注册一个全局组件，可以使用 Vue.component(tagName, options)。123Vue.component('my-component', &#123; // 选项&#125;) 组件在注册之后，便可以在父实例的模块中以自定义元素 的形式使用。1234567891011&lt;div id="example"&gt; &lt;my-component&gt;&lt;/my-component&gt;&lt;/div&gt;// 全局注册Vue.component('my-component', &#123; template: '&lt;div&gt;A custom component!&lt;/div&gt;'&#125;)// 创建根实例new Vue(&#123; el: '#example'&#125;) 除了全局注册还有局部注册12345678910var Child = &#123; template: '&lt;div&gt;A custom component!&lt;/div&gt;'&#125;new Vue(&#123; // ... components: &#123; // &lt;my-component&gt; 将只在父模板可用 'my-component': Child &#125;&#125;) 注意！在组件中 data 必须是一个函数。 构成组件使用prop传递数据通常父子组件有这样的关系：组件 A 在它的模版中使用了组件 B 。它们之间必然需要相互通信：父组件要给子组件传递数据，子组件需要将它内部发生的事情告知给父组件。在 Vue.js 中，父子组件的关系可以总结为 props down, events up 。父组件通过 props 向下传递数据给子组件，子组件通过 events 给父组件发送消息。prop 是父组件用来传递数据的一个自定义属性。子组件需要显式地用 props 选项声明 “prop”。123456789Vue.component('child', &#123; // 声明 props props: ['message'], // 就像 data 一样，prop 可以用在模板内 // 同样也可以在 vm 实例中像 “this.message” 这样使用 template: '&lt;span&gt;&#123;&#123; message &#125;&#125;&lt;/span&gt;'&#125;)然后向它传入一个普通字符串：&lt;child message="hello!"&gt;&lt;/child&gt; 注意！当使用非字符串模版时，prop的名字形式会以如下形式转为短横线隔开：1234567Vue.component('child', &#123; // camelCase in JavaScript props: ['myMessage'], template: '&lt;span&gt;&#123;&#123; myMessage &#125;&#125;&lt;/span&gt;'&#125;)&lt;!-- kebab-case in HTML --&gt;&lt;child my-message="hello!"&gt;&lt;/child&gt; 可以用 v-bind 动态绑定 props 的值到父组件的数据中。每当父组件的数据变化时，该变化也会传导给子组件：12345&lt;div&gt; &lt;input v-model="parentMsg"&gt; &lt;br&gt; &lt;child v-bind:my-message="parentMsg"&gt;&lt;/child&gt;&lt;/div&gt; 单向数据流prop 是单向绑定的：当父组件的属性变化时，将传导给子组件，但是不会反过来。这是为了防止子组件无意修改了父组件的状态。通常有两种改变 prop 的情况：prop 作为初始值传入，子组件之后只是将它的初始值作为本地数据的初始值使用；prop 作为需要被转变的原始值传入。1.定义一个局部 data 属性，并将 prop 的初始值作为局部数据的初始值。1234props: ['initialCounter'],data: function () &#123; return &#123; counter: this.initialCounter &#125;&#125; 2.定义一个 computed 属性，此属性从 prop 的值计算得出。123456props: ['size'],computed: &#123; normalizedSize: function () &#123; return this.size.trim().toLowerCase() &#125;&#125; prop验证组件可以为 props 指定验证要求。如果未指定验证要求，Vue 会发出警告。prop 是一个对象而不是字符串数组时，它包含验证要求：12345678910111213141516171819202122232425262728293031Vue.component('example', &#123; props: &#123; // 基础类型检测 （`null` 意思是任何类型都可以） propA: Number, // 多种类型 propB: [String, Number], // 必传且是字符串 propC: &#123; type: String, required: true &#125;, // 数字，有默认值 propD: &#123; type: Number, default: 100 &#125;, // 数组／对象的默认值应当由一个工厂函数返回 propE: &#123; type: Object, default: function () &#123; return &#123; message: 'hello' &#125; &#125; &#125;, // 自定义验证函数 propF: &#123; validator: function (value) &#123; return value &gt; 10 &#125; &#125; &#125;&#125;) type 可以是下面原生构造器：String Number Boolean Function Object Array 自定义事件使用v-on绑定自定义事件$on(eventName) 监听事件$emit(eventName) 触发事件父组件可以在使用子组件的地方直接用 v-on 来监听子组件触发的事件。1234567891011121314151617181920212223242526272829303132&lt;div id="counter-event-example"&gt; &lt;p&gt;&#123;&#123; total &#125;&#125;&lt;/p&gt; &lt;button-counter v-on:increment="incrementTotal"&gt;&lt;/button-counter&gt; &lt;button-counter v-on:increment="incrementTotal"&gt;&lt;/button-counter&gt;&lt;/div&gt;&lt;script&gt;Vue.component('button-counter', &#123; template: '&lt;button v-on:click="increment"&gt;&#123;&#123; counter &#125;&#125;&lt;/button&gt;', data: function () &#123; return &#123; counter: 0 &#125; &#125;, methods: &#123; increment: function () &#123; this.counter += 1 this.$emit('increment') &#125; &#125;&#125;)new Vue(&#123; el: '#counter-event-example', data: &#123; total: 0 &#125;, methods: &#123; incrementTotal: function () &#123; this.total += 1 &#125; &#125;&#125;)&lt;/script&gt; 非父子组件通信有时候非父子关系的组件也需要通信。在简单的场景下，使用一个空的 Vue 实例作为中央事件总线：1234567var bus = new Vue()// 触发组件 A 中的事件bus.$emit('id-selected', 1)// 在组件 B 创建的钩子中监听事件bus.$on('id-selected', function (id) &#123; // ...&#125;) 使用slot分发内容slot 元素Vue.js 实现的一个内容分发 API，来作为作为原始内容的插槽。子组件模板包含至少一个 slot插口，否则父组件的内容将会被丢弃。当子组件模板只有一个没有属性的 slot 时，父组件整个内容片段将插入到 slot 所在的 DOM 位置，并替换掉 slot 标签本身。假定 my-component 组件有下面模板：1234567891011121314151617181920212223&lt;div&gt; &lt;h2&gt;我是子组件的标题&lt;/h2&gt; &lt;slot&gt; 只有在没有要分发的内容时才会显示。 &lt;/slot&gt;&lt;/div&gt;父组件模版：&lt;div&gt; &lt;h1&gt;我是父组件的标题&lt;/h1&gt; &lt;my-component&gt; &lt;p&gt;这是一些初始内容&lt;/p&gt; &lt;p&gt;这是更多的初始内容&lt;/p&gt; &lt;/my-component&gt;&lt;/div&gt;渲染结果：&lt;div&gt; &lt;h1&gt;我是父组件的标题&lt;/h1&gt; &lt;div&gt; &lt;h2&gt;我是子组件的标题&lt;/h2&gt; &lt;p&gt;这是一些初始内容&lt;/p&gt; &lt;p&gt;这是更多的初始内容&lt;/p&gt; &lt;/div&gt;&lt;/div&gt; slot元素可以用一个特殊的属性 name 来配置如何分发内容。多个 slot 可以有不同的名字。具名 slot 将匹配内容片段中有对应 slot 特性的元素。仍然可以有一个匿名 slot ，它是默认 slot ，作为找不到匹配的内容片段的备用插槽。如果没有默认的 slot ，这些找不到匹配的内容片段将被抛弃。假定我们有一个 app-layout 组件，它的模板为：1234567891011&lt;div class="container"&gt; &lt;header&gt; &lt;slot name="header"&gt;&lt;/slot&gt; &lt;/header&gt; &lt;main&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/main&gt; &lt;footer&gt; &lt;slot name="footer"&gt;&lt;/slot&gt; &lt;/footer&gt;&lt;/div&gt; 父组件模版：123456&lt;app-layout&gt; &lt;h1 slot="header"&gt;这里可能是一个页面标题&lt;/h1&gt; &lt;p&gt;主要内容的一个段落。&lt;/p&gt; &lt;p&gt;另一个主要段落。&lt;/p&gt; &lt;p slot="footer"&gt;这里有一些联系信息&lt;/p&gt;&lt;/app-layout&gt; 渲染结果为：123456789101112&lt;div class="container"&gt; &lt;header&gt; &lt;h1&gt;这里可能是一个页面标题&lt;/h1&gt; &lt;/header&gt; &lt;main&gt; &lt;p&gt;主要内容的一个段落。&lt;/p&gt; &lt;p&gt;另一个主要段落。&lt;/p&gt; &lt;/main&gt; &lt;footer&gt; &lt;p&gt;这里有一些联系信息&lt;/p&gt; &lt;/footer&gt;&lt;/div&gt; vue.js 2.1.0 新增作用域插槽,这是一种特殊类型的插槽，用作使用一个（能够传递数据到）可重用模板替换已渲染元素。在子组件中，只需将数据传递到插槽，就像你将 prop 传递给组件一样：123&lt;div class="child"&gt; &lt;slot text="hello from child"&gt;&lt;/slot&gt;&lt;/div&gt; 在父级中，具有特殊属性 scope 的 template元素，表示它是作用域插槽的模板。scope 的值对应一个临时变量名，此变量接收从子组件中传递的 prop 对象：12345678&lt;div class="parent"&gt; &lt;child&gt; &lt;template scope="props"&gt; &lt;span&gt;hello from parent&lt;/span&gt; &lt;span&gt;&#123;&#123; props.text &#125;&#125;&lt;/span&gt; &lt;/template&gt; &lt;/child&gt;&lt;/div&gt; 渲染得到：123456&lt;div class="parent"&gt; &lt;div class="child"&gt; &lt;span&gt;hello from parent&lt;/span&gt; &lt;span&gt;hello from child&lt;/span&gt; &lt;/div&gt;&lt;/div&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[vue.js学习(二)]]></title>
      <url>%2Fposts%2F5272%2F</url>
      <content type="text"><![CDATA[指令指令是带有 v- 前缀的特殊属性。指令用于在表达式的值改变时，将某些行为应用到 DOM 上。 v-text更新元素的文本内容1234567891011&lt;span v-text="msg"&gt;&lt;/span&gt;&lt;script&gt; new Vue(&#123; el: 'span', data () &#123; return &#123; msg: '路漫漫其修远兮，吾将上下而求索' &#125; &#125; &#125;) &lt;/script&gt; 页面会显示返回的msg内容. v-html用于输出html代码1234567891011&lt;span v-html="msg"&gt;&lt;/span&gt;&lt;script&gt; new Vue(&#123; el: 'span', data () &#123; return &#123; msg: '&lt;h1&gt;路漫漫其修远兮，吾将上下而求索&lt;/h1&gt;' &#125; &#125; &#125;) &lt;/script&gt; 上例中data中返回的带有h1标签的数据通过v-html绑定并输出到span下。注意！在网站上动态渲染任意 HTML 是非常危险的，因为容易导致 XSS 攻击。只在可信内容上使用 v-html，永不用在用户提交的内容上。 v-show根据表达式之真假值，切换元素的display CSS属性。1234567891011&lt;h1 v-show="isShow"&gt;路漫漫其修远兮&lt;/h1&gt;&lt;script&gt; new Vue(&#123; el: 'h1', data () &#123; return &#123; isShow:true &#125; &#125; &#125;) &lt;/script&gt; 这里页面会显示后面的文字，在谷歌浏览器开发者工具下可以看到此时h1的display属性为block，当把true改为false时，h1的display属性就变成为none。 v-if根据表达式的值的真假条件渲染元素。在切换时元素及它的数据绑定/组件被销毁并重建。1234567891011&lt;h1 v-uf="isShow"&gt;路漫漫其修远兮&lt;/h1&gt;&lt;script&gt; new Vue(&#123; el: 'h1', data () &#123; return &#123; isShow:true &#125; &#125; &#125;) &lt;/script&gt; 这段代码当把isShow的值改为false时，h1标签直接被销毁了。 v-if vs v-show通过上面2个例子可以发现v-if和v-show的区别，v-if是真实的条件渲染，因为它会确保条件切换销毁或重建dom、条件块内的事件监听器、子组件。v-show则是元素始终被编译并保留，只是简单地基于CSS切换。一般来说， v-if 有更高的切换消耗而 v-show 有更高的初始渲染消耗。因此，如果需要频繁切换使用 v-show 较好，如果在运行时条件不大可能改变则使用 v-if 较好。 v-elsev-else 指令给 v-if 添加一个 “else” 块123456&lt;div v-if="Math.random() &gt; 0.5"&gt; Sorry&lt;/div&gt;&lt;div v-else&gt; Not sorry&lt;/div&gt; v-else 元素必须紧跟在 v-if 元素或者 v-else-if的后面——否则它不能被识别。 v-else-ifv-else-if，用作 v-if 的 else-if 块。可以链式的多次使用123456789101112&lt;div v-if="type === 'A'"&gt; A&lt;/div&gt;&lt;div v-else-if="type === 'B'"&gt; B&lt;/div&gt;&lt;div v-else-if="type === 'C'"&gt; C&lt;/div&gt;&lt;div v-else&gt; Not A/B/C&lt;/div&gt; 与 v-else 相似，v-else-if 必须跟在 v-if 或者 v-else-if之后。 v-for对源数据进行遍历渲染1234567891011121314&lt;ul id="example-1"&gt; &lt;li v-for="item in items"&gt; &#123;&#123; item.message &#125;&#125; &lt;/li&gt;&lt;/ul&gt;var example1 = new Vue(&#123; el: '#example-1', data: &#123; items: [ &#123;message: '努力' &#125;, &#123;message: '向前' &#125; ] &#125;&#125;) 页面显示努力，向前。v-for 还支持一个可选的第二个参数为当前项的索引。123&lt;li v-for="(item, index) in items"&gt; &#123;&#123; parentMessage &#125;&#125; - &#123;&#123; index &#125;&#125; - &#123;&#123; item.message &#125;&#125; &lt;/li&gt; v-for 也可以取整数123&lt;div&gt; &lt;span v-for="n in 6"&gt;&#123;&#123; n &#125;&#125;&lt;/span&gt;&lt;/div&gt; 结果：123456 v-on绑定事件监听器。事件类型由参数指定。v-on用在普通元素上时，只能监听 原生 DOM 事件。用在自定义元素组件上时，也可以监听子组件触发的自定义事件。1&lt;button v-on:click="doThis"&gt;&lt;/button&gt; 除了直接绑定到一个方法，也可以用内联 JavaScript 语句.123456789101112&lt;div id="example-3"&gt; &lt;button v-on:click="say('hi')"&gt;Say hi&lt;/button&gt; &lt;button v-on:click="say('what')"&gt;Say what&lt;/button&gt;&lt;/div&gt;new Vue(&#123; el: '#example-3', methods: &#123; say: function (message) &#123; alert(message) &#125; &#125;&#125;) v-for还有很多事件修饰符，非常方便。.stop - 调用 event.stopPropagation()，阻止单击事件冒泡.prevent - 调用 event.preventDefault()，提交事件不再重载页面.capture - 添加事件侦听器时使用 capture（捕获） 模式，添加事件侦听器时使用事件捕获模式.self - 只当事件是从侦听器绑定的元素本身触发时才触发回调.keyCode 按键修饰符12&lt;!-- 停止冒泡 --&gt;&lt;button @click.stop="doThis"&gt;&lt;/button&gt; vue.js中v-on还可以简写成@如上例中所示 v-bind动态地绑定一个或多个特性，在vue.js里v-bind常用在class与style绑定，可以传给 v-bind:class 一个对象，以动态地切换 class 。12345&lt;div v-bind:class="&#123; active: isActive &#125;"&gt;&lt;/div&gt;...data: &#123; isActive: true, &#125; 当返回的是true时div就添加class=isActive，也可以直接绑定数据里的一个对象：123456&lt;div v-bind:class="classObject"&gt;&lt;/div&gt;data: &#123; classObject: &#123; active: true &#125;&#125; 得到的结果和上例一样。也可以把一个数组传给 v-bind:class ，以应用一个 class 列表12345&lt;div v-bind:class="[activeClass, errorClass]"&gt;&lt;/div&gt;data: &#123; activeClass: 'active', errorClass: 'text-danger'&#125; 渲染为:1&lt;div class="active text-danger"&gt;&lt;/div&gt; v-bind也有缩写就是冒号：1&lt;div :class="[classA, classB]"&gt;&lt;/div&gt; v-model基本用法在表单控件或者组件上创建双向绑定,本质上是一个语法糖，它负责监听用户的输入事件以更新数据12&lt;input v-model="message" placeholder="edit me"&gt;&lt;p&gt;Message is: &#123;&#123; message &#125;&#125;&lt;/p&gt; 在输入框输入内容，p标签也会随着更新。复选框如果是一个为逻辑值，如果是多个则绑定到同一个数组：12345678910111213141516171819202122232425&lt;div id="app"&gt; &lt;p&gt;单个复选框：&lt;/p&gt; &lt;input type="checkbox" id="checkbox" v-model="checked"&gt; &lt;label for="checkbox"&gt;&#123;&#123; checked &#125;&#125;&lt;/label&gt; &lt;p&gt;多个复选框：&lt;/p&gt; &lt;input type="checkbox" id="runoob" value="baidu" v-model="checkedNames"&gt; &lt;label for="runoob"&gt;Runoob&lt;/label&gt; &lt;input type="checkbox" id="google" value="Google" v-model="checkedNames"&gt; &lt;label for="google"&gt;Google&lt;/label&gt; &lt;input type="checkbox" id="taobao" value="Taobao" v-model="checkedNames"&gt; &lt;label for="taobao"&gt;taobao&lt;/label&gt; &lt;br&gt; &lt;span&gt;选择的值为: &#123;&#123; checkedNames &#125;&#125;&lt;/span&gt;&lt;/div&gt; &lt;script&gt;new Vue(&#123; el: '#app', data: &#123; checked : false, checkedNames: [] &#125;&#125;)&lt;/script&gt; 上例中多个复选框都绑定到checkedNames，单选按钮个和select列表与复选框类似都是绑定到同一个变量。 修饰符.lazy 默认情况，v-model 在 input 事件中同步输入框的值与数据，添加修饰符lazy，转变为在 change 事件中同步 .number自动将用户的输入值转为 Number 类型1&lt;input v-model.number="age" type="number"&gt; .trim自动过滤用户输入的首尾空格1&lt;input v-model.trim="msg"&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[es6的新特性(四)]]></title>
      <url>%2Fposts%2F17683%2F</url>
      <content type="text"><![CDATA[Iterator和for…of循环Iterator（遍历器）Iterator的概念到了es6,js就有了四种数据集合,数组、对象、Map、Set，实际开发中可以组合使用这些数据集合，定义自己的数据结构，那么需要一种统一的接口机制，来处理所有不同的数据结构。遍历器（Iterator）就是这样一种机制。它是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署Iterator接口，就可以完成遍历操作（即依次处理该数据结构的所有成员）。Iterator的遍历过程是这样的。（1）创建一个指针对象，指向当前数据结构的起始位置。也就是说，遍历器对象本质上，就是一个指针对象。（2）第一次调用指针对象的next方法，可以将指针指向数据结构的第一个成员。（3）第二次调用指针对象的next方法，指针就指向数据结构的第二个成员。（4）不断调用指针对象的next方法，直到它指向数据结构的结束位置。每一次调用next方法，都会返回一个包含value和done两个属性的对象。其中，value属性是当前成员的值，done属性是一个布尔值，表示遍历是否结束。1234567891011121314var it = makeIterator(['a', 'b']);it.next() // &#123; value: "a", done: false &#125;it.next() // &#123; value: "b", done: false &#125;it.next() // &#123; value: undefined, done: true &#125;function makeIterator(array) &#123; var nextIndex = 0; return &#123; next: function() &#123; return nextIndex &lt; array.length ? &#123;value: array[nextIndex++], done: false&#125; : &#123;value: undefined, done: true&#125;; &#125; &#125;;&#125; 这段代码定义了一个makeIterator函数，它是一个遍历器生成函数，作用就是返回一个遍历器对象。next方法返回一个对象，表示当前数据成员的信息。这个对象具有value和done两个属性，value属性返回当前位置的成员，done属性是一个布尔值，表示遍历是否结束，即是否还有必要再一次调用next方法。ES6规定，默认的Iterator接口部署在数据结构的Symbol.iterator属性，或者说，一个数据结构只要具有Symbol.iterator属性，就可以认为是“可遍历的”（iterable）有三类数据结构原生具备Iterator接口：数组、某些类似数组的对象、Set和Map结构。123456let arr = ['a', 'b', 'c'];let iter = arr[Symbol.iterator]();iter.next() // &#123; value: 'a', done: false &#125;iter.next() // &#123; value: 'b', done: false &#125;iter.next() // &#123; value: 'c', done: false &#125;iter.next() // &#123; value: undefined, done: true&#125; 这里变量arr是一个数组，原生就具有遍历器接口，部署在arr的Symbol.iterator属性上面。所以，调用这个属性，就得到遍历器对象。有些数据结构（主要是对象）的Iterator接口需要自己在Symbol.iterator属性上面部署，这样才会被for…of循环遍历。 调用Iterator接口的场合解构赋值对数组和Set结构进行解构赋值时，会默认调用Symbol.iterator方法12345let set = new Set().add('a').add('b').add('c');let [x,y] = set;// x='a'; y='b'let [first, ...rest] = set;// first='a'; rest=['b','c']; 扩展运算符1234567// 例一var str = 'hello';[...str] // ['h','e','l','l','o']// 例二let arr = ['b', 'c'];['a', ...arr, 'd']// ['a', 'b', 'c', 'd'] 上面代码的扩展运算符内部就调用Iterator接口。实际上，这提供了一种简便机制，可以将任何部署了Iterator接口的数据结构，转为数组。也就是说，只要某个数据结构部署了Iterator接口，就可以对它使用扩展运算符，将其转为数组。 yield*yield*后面跟的是一个可遍历的结构，它会调用该结构的遍历器接口。123456789101112let generator = function* () &#123; yield 1; yield* [2,3,4]; yield 5;&#125;;var iterator = generator();iterator.next() // &#123; value: 1, done: false &#125;iterator.next() // &#123; value: 2, done: false &#125;iterator.next() // &#123; value: 3, done: false &#125;iterator.next() // &#123; value: 4, done: false &#125;iterator.next() // &#123; value: 5, done: false &#125;iterator.next() // &#123; value: undefined, done: true &#125; 字符串的Iterator接口字符串是一个类似数组的对象，也原生具有Iterator接口。1234567var someString = "hi";typeof someString[Symbol.iterator]// "function"var iterator = someString[Symbol.iterator]();iterator.next() // &#123; value: "h", done: false &#125;iterator.next() // &#123; value: "i", done: false &#125;iterator.next() // &#123; value: undefined, done: true &#125; 上面代码中，调用Symbol.iterator方法返回一个遍历器对象，在这个遍历器上可以调用next方法，实现对于字符串的遍历。 for…of循环ES6引入了for…of循环，作为遍历所有数据结构的统一的方法。for…of循环内部调用的是数据结构的Symbol.iterator方法。for…of循环可以使用的范围包括数组、Set 和 Map 结构、某些类似数组的对象（比如arguments对象、DOM NodeList 对象）以及字符串。 数组for…of循环可以代替数组实例的forEach方法。12345const arr = ['red', 'green', 'blue'];arr.forEach(function (element, index) &#123; console.log(element); // red green blue console.log(index); // 0 1 2&#125;); es5中的for…in循环，只能获得对象的键名，不能直接获取键值。ES6提供for…of循环，允许遍历获得键值。1234567var arr = ['a', 'b', 'c', 'd'];for (let a in arr) &#123; console.log(a); // 0 1 2 3&#125;for (let a of arr) &#123; console.log(a); // a b c d&#125; 上例中for…in循环读取键名，for…of循环读取键值。如果要通过for…of循环，获取数组的索引，可以借助数组实例的entries方法和keys方法。 Set和Map结构Set和Map结构也原生具有Iterator接口，可以直接使用for…of循环。1234567891011121314151617var engines = new Set(["Gecko", "Trident", "Webkit", "Webkit"]);for (var e of engines) &#123; console.log(e);&#125;// Gecko// Trident// Webkitvar es6 = new Map();es6.set("edition", 6);es6.set("committee", "TC39");es6.set("standard", "ECMA-262");for (var [name, value] of es6) &#123; console.log(name + ": " + value);&#125;// edition: 6// committee: TC39// standard: ECMA-262 上例演示了如何遍历Set结构和Map结构。值得注意的地方有两个，首先，遍历的顺序是按照各个成员被添加进数据结构的顺序。其次，Set结构遍历时，返回的是一个值，而Map结构遍历时，返回的是一个数组，该数组的两个成员分别为当前Map成员的键名和键值。 类似数组的对象类似数组的对象包括好几类。下面是for…of循环用于字符串、DOM NodeList对象、arguments对象的例子。12345678910111213141516171819// 字符串let str = "hello";for (let s of str) &#123; console.log(s); // h e l l o&#125;// DOM NodeList对象let paras = document.querySelectorAll("p");for (let p of paras) &#123; p.classList.add("test");&#125;// arguments对象function printArgs() &#123; for (let x of arguments) &#123; console.log(x); &#125;&#125;printArgs('a', 'b');// 'a'// 'b' 并不是所有类似数组的对象都具有iterator接口，一个简便的解决方法，就是使用Array.from方法将其转为数组。123456789let arrayLike = &#123; length: 2, 0: 'a', 1: 'b' &#125;;// 报错for (let x of arrayLike) &#123; console.log(x);&#125;// 正确for (let x of Array.from(arrayLike)) &#123; console.log(x);&#125; 对象普通对象，for…of结构不能直接使用，会报错，必须部署了iterator接口后才能使用。但for…in循环依然可以用来遍历键名。123456789101112131415var es6 = &#123; edition: 6, committee: "TC39", standard: "ECMA-262"&#125;;for (let e in es6) &#123; console.log(e);&#125;// edition// committee// standardfor (let e of es6) &#123; console.log(e);&#125;// TypeError: es6 is not iterable 解决方法是，使用Object.keys方法将对象的键名生成一个数组，然后遍历这个数组。123for (var key of Object.keys(someObject)) &#123; console.log(key + ": " + someObject[key]);&#125; for…of循环的优点1.有着同for…in一样的简洁语法，但是没有for…in那些缺点，for…in的主要缺点：（1）数组的键名是数字，但是for…in循环是以字符串作为键名“0”、“1”、“2”等等。（2）for…in循环不仅遍历数字键名，还会遍历手动添加的其他键，甚至包括原型链上的键。（3）某些情况下，for…in循环会以任意顺序遍历键名。2.不同用于forEach方法，它可以与break、continue和return配合使用。3.提供了遍历所有数据结构的统一操作接口.12345for (var n of fibonacci) &#123; if (n &gt; 1000) break; console.log(n);&#125; 上面的例子，会输出斐波纳契数列小于等于1000的项。如果当前项大于1000，就会使用break语句跳出for…of循环。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[es6的新特性(三)]]></title>
      <url>%2Fposts%2F54255%2F</url>
      <content type="text"><![CDATA[Set和Map数据结构Setes6提供了新的数据结构Set（S是大写的）,跟数组很像，但是成员的值都是唯一的。123456var s = new Set();[2, 3, 5, 4, 5, 2, 2].map(x =&gt; s.add(x));for (let i of s) &#123; console.log(i);&#125;// 2 3 5 4 重复的值会自动去掉。ps:add是Set实例的操作方法Set函数可以接受一个数组（或类似数组的对象）作为参数，用来初始化。123var set = new Set([1, 2, 3, 4, 4]);[...set]// [1, 2, 3, 4] 由此有一种数组去重的方法12// 去除数组的重复成员[...new Set(array)] 注意！向Set加入值的时候，不会发生类型转换，所以5和”5”是两个不同的值。Set内部判断两个值是否不同，使用的算法叫做“Same-value equality”，它类似于精确相等运算符（===），主要的区别是NaN等于自身，而精确相等运算符认为NaN不等于自身。123456let set = new Set();let a = NaN;let b = NaN;set.add(a);set.add(b);set // Set &#123;NaN&#125; 上例中向Set实例添加了两个NaN，但是只能加入一个。这表明，在Set内部，两个NaN是相等。Set实例有自己属性和方法Set.prototype.constructor:构造函数，默认就是Set函数。Set.prototype.size:返回Set实例的成员总数。Set实例的方法分为两大类：操作方法（用于操作数据）和遍历方法（用于遍历成员)add(value):添加某个值，返回Set结构本身。delete(value):添加某个值，返回Set结构本身。has(value):返回一个布尔值，表示该值是否为Set的成员。clear():清除所有成员，没有返回值。123456789s.add(1).add(2).add(2);// 注意2被加入了两次s.size // 2s.has(1) // trues.has(2) // trues.has(3) // falses.delete(2);s.has(2) // false Array.from方法可以将Set结构转为数组。12var items = new Set([1, 2, 3, 4, 5]);var array = Array.from(items); 由此就有了数组去重的方法1234function dedupe(array) &#123; return Array.from(new Set(array));&#125;dedupe([1, 1, 2, 3]) // [1, 2, 3] Set结构的实例有四个遍历方法，可以用于遍历成员。keys():返回键名的遍历器values():返回键值的遍历器entries():返回键值对的遍历器forEach():使用回调函数遍历每个成员特别指出的是，Set的遍历顺序就是插入顺序。这个特性有时非常有用，比如使用Set保存一个回调函数列表，调用时就能保证按照添加顺序调用。keys方法、values方法、entries方法返回的都是遍历器对象。由于 Set 结构没有键名，只有键值（或者说键名和键值是同一个值），所以keys方法和values方法的行为完全一致。12345678910111213141516171819let set = new Set(['red', 'green', 'blue']);for (let item of set.keys()) &#123; console.log(item);&#125;// red// green// bluefor (let item of set.values()) &#123; console.log(item);&#125;// red// green// bluefor (let item of set.entries()) &#123; console.log(item);&#125;// ["red", "red"]// ["green", "green"]// ["blue", "blue"] 上例中，entries方法返回的遍历器，同时包括键名和键值，所以每次输出一个数组，它的两个成员完全相等。Set结构的实例默认可遍历，它的默认遍历器生成函数就是它的values方法。意味着我们可以使用for…of循环遍历Set。1234567let set = new Set(['red', 'green', 'blue']);for (let x of set) &#123; console.log(x);&#125;// red// green// blue 扩展运算符（…）内部使用for…of循环，所以也可以用于Set结构。123let set = new Set(['red', 'green', 'blue']);let arr = [...set];// ['red', 'green', 'blue'] 扩展运算符和Set结构相结合，就可以去除数组的重复成员。123let arr = [3, 5, 2, 2, 5, 5];let unique = [...new Set(arr)];// [3, 5, 2] 数组的map和filter方法也可以用于Set123456let set = new Set([1, 2, 3]);set = new Set([...set].map(x =&gt; x * 2));// 返回Set结构：&#123;2, 4, 6&#125;let set = new Set([1, 2, 3, 4, 5]);set = new Set([...set].filter(x =&gt; (x % 2) == 0));// 返回Set结构：&#123;2, 4&#125; WeakSet结构与Set类似，也是不重复的值的集合。但是，它与Set有两个区别。首先，WeakSet的成员只能是对象，而不能是其他类型的值。其次，WeakSet中的对象都是弱引用，即垃圾回收机制不考虑WeakSet对该对象的引用，也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于WeakSet之中。这个特点意味着，无法引用WeakSet的成员，因此WeakSet是不可遍历的。WeakSet是一个构造函数，可以使用new命令，创建WeakSet数据结构。作为构造函数，WeakSet可以接受一个数组或类似数组的对象作为参数。该数组的所有成员，都会自动成为WeakSet实例对象的成员。12var a = [[1,2], [3,4]];var ws = new WeakSet(a); WeakSet没有size属性，没有办法遍历它的成员,因为成员都是弱引用，随时可能消失，遍历机制无法保证成员的存在，很可能刚刚遍历结束，成员就取不到了。WeakSet的一个用处，是储存DOM节点，而不用担心这些节点从文档移除时，会引发内存泄漏。1234567891011const foos = new WeakSet()class Foo &#123; constructor() &#123; foos.add(this) &#125; method () &#123; if (!foos.has(this)) &#123; throw new TypeError('Foo.prototype.method 只能在Foo的实例上调用！'); &#125; &#125;&#125; 上面代码保证了Foo的实例方法，只能在Foo的实例上调用。这里使用WeakSet的好处是，foos对实例的引用，不会被计入内存回收机制，所以删除实例的时候，不用考虑foos，也不会出现内存泄漏。 MapMap结构的目的和基本用法Map类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。也就是说，Object结构提供了“字符串—值”的对应，Map结构提供了“值—值”的对应，是一种更完善的Hash结构实现。如果你需要“键值对”的数据结构，Map比Object更合适。1234567var m = new Map();var o = &#123;p: 'Hello World'&#125;;m.set(o, 'content')m.get(o) // "content"m.has(o) // truem.delete(o) // truem.has(o) // false 上面代码使用set方法，将对象o当作m的一个键，然后又使用get方法读取这个键，接着使用delete方法删除了这个键。Map也可以接受一个数组作为参数。该数组的成员是一个个表示键值对的数组。123456789var map = new Map([ ['name', '张三'], ['title', 'Author']]);map.size // 2map.has('name') // truemap.get('name') // "张三"map.has('title') // truemap.get('title') // "Author" 上面代码在新建Map实例时，就指定了两个键name和title。注意字符串true和布尔值true是两个不同的键。123456var m = new Map([ [true, 'foo'], ['true', 'bar']]);m.get(true) // 'foo'm.get('true') // 'bar' 如果对同一个键多次赋值，后面的值将覆盖前面的值。12345let map = new Map();map.set(1, 'aaa').set(1, 'bbb');map.get(1) // "bbb" Map的键是跟内存地址绑定的，只要内存地址不一样，就视为两个键。12345678var map = new Map();var k1 = ['a'];var k2 = ['a'];map.set(k1, 111).set(k2, 222);map.get(k1) // 111map.get(k2) // 222 实例的属性和操作方法size属性返回Map结构的成员总数1234let map = new Map();map.set('foo', true);map.set('bar', false);map.size // 2 Map的set方法设置key所对应的键值，然后返回整个Map结构。如果key已经有值，则键值会被更新，否则就新生成该键。set方法返回的是Map本身，因此可以采用链式写法。1234let map = new Map() .set(1, 'a') .set(2, 'b') .set(3, 'c'); get方法读取key对应的键值，如果找不到key，返回undefined。has方法返回一个布尔值，表示某个键是否在Map数据结构中。delete方法删除某个键，返回true。如果删除失败，返回false。clear方法清除所有成员，没有返回值。 遍历方法keys():返回键名的遍历器values():返回键值的遍历器entries():返回所有成员的遍历器forEach():遍历Map的所有成员注意！Map的遍历顺序就是插入顺序Map结构转为数组结构，比较快速的方法是结合使用扩展运算符（…）。12345678910111213let map = new Map([ [1, 'one'], [2, 'two'], [3, 'three'],]);[...map.keys()]// [1, 2, 3][...map.values()]// ['one', 'two', 'three'][...map.entries()]// [[1,'one'], [2, 'two'], [3, 'three']][...map]// [[1,'one'], [2, 'two'], [3, 'three']] 结合数组的map方法、filter方法，可以实现Map的遍历和过滤（Map本身没有map和filter方法）。123456789101112let map0 = new Map() .set(1, 'a') .set(2, 'b') .set(3, 'c');let map1 = new Map( [...map0].filter(([k, v]) =&gt; k &lt; 3));// 产生Map结构 &#123;1 =&gt; 'a', 2 =&gt; 'b'&#125;let map2 = new Map( [...map0].map(([k, v]) =&gt; [k * 2, '_' + v]) );// 产生Map结构 &#123;2 =&gt; '_a', 4 =&gt; '_b', 6 =&gt; '_c'&#125; 与其他数据结构的互相转换Map转为数组最方便的方法，就是使用扩展运算符（…）。123let myMap = new Map().set(true, 7).set(&#123;foo: 3&#125;, ['abc']);[...myMap]// [ [ true, 7 ], [ &#123; foo: 3 &#125;, [ 'abc' ] ] ] 将数组转入Map构造函数，就可以转为Map。12new Map([[true, 7], [&#123;foo: 3&#125;, ['abc']]])// Map &#123;true =&gt; 7, Object &#123;foo: 3&#125; =&gt; ['abc']&#125; 如果所有Map的键都是字符串，它可以转为对象。12345678910function strMapToObj(strMap) &#123; let obj = Object.create(null); for (let [k,v] of strMap) &#123; obj[k] = v; &#125; return obj;&#125;let myMap = new Map().set('yes', true).set('no', false);strMapToObj(myMap)// &#123; yes: true, no: false &#125; Map转为JSON，分两种情况，一种情况是，Map的键名都是字符串，这时可以选择转为对象JSON。1234567function strMapToJson(strMap) &#123; return JSON.stringify(strMapToObj(strMap));&#125;//先转化为对象再使用JSON.stringify方法let myMap = new Map().set('yes', true).set('no', false);strMapToJson(myMap)// '&#123;"yes":true,"no":false&#125;' 另一种情况是，Map的键名有非字符串，这时可以选择转为数组JSON。123456function mapToArrayJson(map) &#123; return JSON.stringify([...map]);&#125;let myMap = new Map().set(true, 7).set(&#123;foo: 3&#125;, ['abc']);mapToArrayJson(myMap)// '[[true,7],[&#123;"foo":3&#125;,["abc"]]]']]></content>
    </entry>

    
    <entry>
      <title><![CDATA[es6的新特性(二)]]></title>
      <url>%2Fposts%2F17229%2F</url>
      <content type="text"><![CDATA[变量的解构赋值数组的解构赋值在es5中，为变量赋值，只能直接指定值，如下所示123var a = 1;var b = 2;var c = 3; es6中可以这样写1var [a, b, c] = [1, 2, 3]; 上面代码中，数组对应位置，为变量赋值。只要等号两边的模式相同，左边的变量就会被赋予对应的值。例如可以嵌套数组解构1234let [foo, [[bar], baz]] = [1, [[2], 3]];foo // 1bar // 2baz // 3 根据数组的属性还可以这样写12let [ , , z] = ["html", "css", "js"];z // "js" 当然如果解构不成功，变量的值就是undefined123var [foo] = [];var [bar, foo] = [1];foo //undefined 上面是等号右边值数量小于左边，看一下另一种情况123let [x, y] = [1, 2, 3];x // 1y // 2 如上所示，这种情况下是可以解构成功，在es6中被称作不完全解构如果等号的右边不是数组将会报错1234567// 报错let [foo] = 1;let [foo] = false;let [foo] = NaN;let [foo] = undefined;let [foo] = null;let [foo] = &#123;&#125;; 解构赋值不仅适用于var命令，也适用于es6新加的let和const命令。解构赋值允许指定默认值。12let [ x='html'] = [];x // html 对象的解构赋值对象的解构与数组有不同，数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。12345var &#123; bar, foo &#125; = &#123; foo: "aaa", bar: "bbb" &#125;;foo // "aaa"bar // "bbb"var &#123; baz &#125; = &#123; foo: "aaa", bar: "bbb" &#125;;baz // undefined 上例中等号左边的两个变量的次序，与等号右边两个同名属性的次序不一致，但是对取值完全没有影响。第二个例子的变量没有对应的同名属性，导致取不到值，最后等于undefined。如果变量名与属性名不一致，必须写成下面这样。1234let obj = &#123; first: 'hello', last: 'world' &#125;;let &#123; first: f, last: l &#125; = obj;f // 'hello'l // 'world' 在es6的对象解构赋值中，变量的声明和赋值是一体的。对于let和const来说，变量不能重新声明，所以一旦赋值的变量以前声明过，就会报错。12345let foo;let &#123;foo&#125; = &#123;foo: 1&#125;; // SyntaxError: Duplicate declaration "foo"let baz;let &#123;bar: baz&#125; = &#123;bar: 1&#125;; // SyntaxError: Duplicate declaration "baz" 上例中，解构赋值的变量都会重新声明，所以报错了。不过，因为var命令允许重新声明，所以这个错误只会在使用let和const命令时出现。如果没有第二个let命令，上面的代码就不会报错。注意，用这种方式必须加上小括号，因为解析器会将起首的大括号，理解成一个代码块，而不是赋值语句。如下所示12345let foo;(&#123;foo&#125; = &#123;foo: 1&#125;); // 成功let baz;(&#123;bar: baz&#125; = &#123;bar: 1&#125;); // 成功 和数组一样，解构也可以用于嵌套结构的对象。12345678let obj = &#123;&#125;;let arr = [];(&#123; foo: obj.prop, bar: arr[0] &#125; = &#123; foo: 123, bar: true &#125;);obj // &#123;prop:123&#125;arr // [true]y // "World" 对象的解构也可以指定默认值。123456var &#123;x = 3&#125; = &#123;&#125;;x // 3var &#123;x, y = 5&#125; = &#123;x: 1&#125;;x // 1y // 5 字符串的解构赋值字符串也可以解构赋值。这是因为，字符串被转换成了一个类似数组的对象。123456const [a, b, c, d, e] = 'hello';a // "h"b // "e"c // "l"d // "l"e // "o" 函数参数的解构赋值1234function add([x, y])&#123; return x + y;&#125;add([1, 2]); // 3 上例中函数add的参数是一个数组，传参时数组参数就被解构成变量x和y。函数参数的解构也可以使用默认值。12345678function move(&#123;x = 0, y = 0&#125; = &#123;&#125;) &#123; return [x, y];&#125;move(&#123;x: 3, y: 8&#125;); // [3, 8]move(&#123;x: 3&#125;); // [3, 0]move(&#123;&#125;); // [0, 0]move(); // [0, 0] 解构赋值的用途交换变量的值1[x, y] = [y, x]; 从函数返回多个值函数只能返回一个值，如果要返回多个值，只能将它们放在数组或对象里返回。有了解构赋值，取出这些值就非常方便。1234567891011121314function box() &#123; return [1, 2, 3];&#125;var [a, b, c] = box();// 返回一个对象function box() &#123; return &#123; foo: 1, bar: 2 &#125;;&#125;var &#123; foo, bar &#125; = box(); 提取JSON数据12345678910var jsonData = &#123; id: 42, status: "OK", data: [867, 5309]&#125;;let &#123; id, status, data: number &#125; = jsonData;console.log(id, status, number);// 42, "OK", [867, 5309]]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[vue学习(一)]]></title>
      <url>%2Fposts%2F49667%2F</url>
      <content type="text"><![CDATA[之前电脑坏了等了好久才修好，拿回来网又出问题了，打了客服电话，慢吞吞才来，于是好久都没更新博客了(我才不会说是懒癌发作)，但是这期间也没闲着，毕竟在这个别人比你富有还比你努力的时代，我这个学渣必须更得努力才是。好罢进入学习中吧。 vue.js是什么vue.js在2016年真是特别的火，基本我加的前端群都差不多有vue.js的讨论，那么vue.js是什么呢，看下vue.js 2.0文档里的说法吧！Vue.js（读音 /vjuː/, 类似于 view） 是一套构建用户界面的渐进式框架。与其他重量级框架不同的是，Vue 采用自底向上增量开发的设计。Vue 的核心库只关注视图层，Vue 完全有能力驱动采用单文件组件和 Vue 生态系统支持的库开发的复杂单页应用。初看这段话初读完全有点晕，看下例子123456789101112131415161718192021&lt;!doctype html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;vue&lt;/title&gt; &lt;script src="http://cdnjs.cloudflare.com/ajax/libs/vue/2.1.3/vue.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="app"&gt; &#123;&#123; message &#125;&#125; &lt;/div&gt;&lt;/body&gt;&lt;script&gt;var app = new Vue(&#123; el: '#app', data: &#123; message: 'Hello 羊羊羊!' &#125;&#125;)&lt;/script&gt;&lt;/html&gt; 运行这段代码，会显示Hello羊羊羊,script里面的message,传入到了div里面，当更改message的值时，页面也会相应改变，再回忆下jQuery，如果jQuery要达到这样的效果就必须先获得message的dom，然后用text()方法进行更改，而vue.js则完全不用这么复杂，使用vue.js后，数据和 DOM 已经被绑定在一起，所有的元素都是响应式的，所以综合来说 vue.js是数据驱动，当数据变化时dom会自动发生更改，不再需要繁杂的dom操作。 vue.js的安装cdn可以直接像引用js文件一样引入,以下是国外比较稳定的两个 CDN12&lt;script src="https://unpkg.com/vue/dist/vue.js"&gt;&lt;/script&gt;&lt;script src="https://cdnjs.cloudflare.com/ajax/libs/vue/2.1.8/vue.min.js"&gt;&lt;/script&gt; 学习环境下这种方式比较好，可根据文档专注于vue.js本身，而不用考虑配置等一些列问题 npm用node.js包管理工具进行安装1$ npm install vue Vue.js 提供一个官方命令行工具，可用于快速搭建大型单页应用具体操作如下1234567# 全局安装 vue-cli$ npm install --global vue-cli# 创建一个基于 webpack 模板的新项目$ vue init webpack my-project# 安装依赖$ cd my-project$ npm install 完毕之后进入项目在进行$ npm run dev命令，打开浏览器输入localhost:8080即可 vue.js 目录结构build 最终发布的代码存放位置。config 配置目录，包括端口号等。我们初学可以使用默认的。node_modules npm 加载的项目依赖模块src 这里是我们要开发的目录，基本上要做的事情都在这个目录里。里面包含了几个目录及文件：commponents: 在src目录下，存放组件文件。App.vue: 在src目录下，是项目入口文件，可以直接将组件写这里，而不使用 commponents 目录。main.js: 在src目录下，项目的核心文件。static 静态资源目录，如图片、字体等。.gitignore文件 这些是一些配置文件，包括语法配置，git配置等。index.html 首页入口文件，可以添加一些 meta 信息或同统计代码啥的。package.json 项目配置文件,包含项目信息、依赖的模块等README.md 项目的说明文档，markdown 格式 vue.js的起步Vue.js 专注于 MVVM 模型的 ViewModel 层，通过双向数据绑定把 View 层和 Model 层连接了起来。vuejs不是一个大而全的框架——它只是一个简单灵活的视图层。 ViewModel同步 Model 和 View 的对象。在 Vue.js 中，每个 Vue 实例都是一个 ViewModel。它们是通过构造函数 Vue 或其子类被创建出来的。1var vm = new Vue(&#123; /* options */ &#125;)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[es6的新特性(一)]]></title>
      <url>%2Fposts%2F33769%2F</url>
      <content type="text"><![CDATA[之前已经看了一遍es6的文档,因为之前学习过其它语言,发现es6的新特性好多都是跟其它语言相似的,例如class,const,然后就没怎么太认真看,但在实际使用中却发现很多东西并不是很熟悉,于是只能认认真真的从头来过,这也让我得到了一个印象深刻的教训,不要凭自己的主观去想当然,在技术的世界里一定要严谨再严谨,好了闲话少述,进入正题。 let基本用法 let和const是es6声明变量的新方法,众所周知,es5申明变量是通过var,var的一大缺点就是没有局部作用域,经常会出现意想不到的错误,es6就顺势推出了let.1234567 &#123; let a = 10; var b = 1; &#125;a // ReferenceError: a is not defined.b // 1 上面代码在代码块之中，分别用let和var声明了两个变量。然后在代码块之外调用这两个变量，结果let声明的变量报错，var声明的变量返回了正确的值。这表明，let声明的变量只在它所在的代码块有效。 再看一个例子1234567var a = [];for (var i = 0; i &lt; 10; i++) &#123; a[i] = function () &#123; console.log(i); &#125;;&#125;a[6](); // 10 这个例子中变量i是var声明的，在全局范围内都有效。所以每一次循环，新的i值都会覆盖旧值，导致最后输出的是最后一轮的i的值,也就是10。 将var改成let1234567var a = [];for (let i = 0; i &lt; 10; i++) &#123; a[i] = function () &#123; console.log(i); &#125;;&#125;a[6](); // 6 上面代码中，变量i是let声明的，当前的i只在本轮循环有效，所以每一次循环的i其实都是一个新的变量，所以最后输出的是6。 暂时性死区块级作用域内存在let命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。12345var tmp = 123;if (true) &#123; tmp = 'abc'; // ReferenceError let tmp;&#125; 上面代码中，存在全局变量tmp，但是块级作用域内let又声明了一个局部变量tmp，导致后者绑定这个块级作用域，所以在let声明变量前，对tmp赋值会报错.在es6中如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称TDZ）。ES6规定暂时性死区和let、const语句不出现变量提升，主要是为了减少运行时错误，防止在变量声明前就使用这个变量，从而导致意料之外的行为。 不允许重复声明let不允许在相同作用域内，重复声明同一个变量。1234567891011// 报错function () &#123; let a = 10; var a = 1;&#125;// 报错function () &#123; let a = 10; let a = 1;&#125; do表达式1234&#123; let t = f(); t = t * t + 1;&#125; 上面代码中，块级作用域将两个语句封装在一起。但是，在块级作用域以外，没有办法得到t的值，因为块级作用域不返回值，除非t是全局变量。那么怎么得到块级作用域的返回值呢?办法就是在块级作用域之前加上do，使它变为do表达式。代码如下:1234&#123; let t = f(); t = t * t + 1;&#125; constconst声明一个只读的常量。一旦声明，常量的值就不能改变。12345const PI = 3.1415;PI // 3.1415PI = 3;// TypeError: Assignment to constant variable. 上面代码表明改变常量的值会报错。const声明的变量不得改变值，这意味着，const一旦声明变量，就必须立即初始化，不能留到以后赋值。同时const的作用域与let命令相同：只在声明所在的块级作用域内有效，声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用,也一样不可重复声明。对于复合类型的变量，变量名不指向数据，而是指向数据所在的地址。const命令只是保证变量名指向的地址不变，并不保证该地址的数据不变，所以将一个对象声明为常量必须非常小心。1234567const foo = &#123;&#125;;foo.prop = 123;foo.prop// 123foo = &#123;&#125;; // TypeError: "foo" is read-only 这段代码中常量foo储存的是一个地址，这个地址指向一个对象。不可变的只是这个地址，即不能把foo指向另一个地址，但对象本身是可变的，所以依然可以为其添加新属性。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[终于搭好了自己的个人博客]]></title>
      <url>%2Fposts%2F53204%2F</url>
      <content type="text"><![CDATA[终于搭建好了自己的个人博客.之前看完node.js和express框架文档后,就想着尝试用express做一个自己的博客,一方面可实践做下项目,另一方面没事写写文章,这可是装逼好能手啊!可是作为懒癌晚期患者,断断续续写了一两个月,也只写了一小部分,但即便如此也死了很多脑细胞,当然也学到很多的知识,正当我还想继续发扬一懒到底精神的时候,某天在技术群看到hexo+github快速搭建博客,关键的是不用买服务器,good!顿时起了兴趣,看了教程就开始入手,不到一个小时主体框架就出来了,心情很鸡冻啊有木有,然后在接下来几天里只要有空就会研究如何去美化这个博客,挑了好久最终挑选了next这个主题,一个个小功能去实现,在实现过程中也发现了很多很好玩的东西,例如:各种以前没听说的第三方好用的服务,也让我收获颇丰,当然总体来说这个博客搭建并没有其他太多的技术含量,还有很多地方也需要改进,哈哈希望能发现更多好玩的东西往里面塞吧!]]></content>
    </entry>

    
  
  
</search>
