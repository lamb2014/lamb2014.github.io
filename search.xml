<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[es6的新特性(三)]]></title>
      <url>%2Fposts%2F54255%2F</url>
      <content type="text"><![CDATA[Set和Map数据结构Setes6提供了新的数据结构Set（S是大写的）,跟数组很像，但是成员的值都是唯一的。123456var s = new Set();[2, 3, 5, 4, 5, 2, 2].map(x =&gt; s.add(x));for (let i of s) &#123; console.log(i);&#125;// 2 3 5 4 重复的值会自动去掉。ps:add是Set实例的操作方法Set函数可以接受一个数组（或类似数组的对象）作为参数，用来初始化。123var set = new Set([1, 2, 3, 4, 4]);[...set]// [1, 2, 3, 4] 由此有一种数组去重的方法12// 去除数组的重复成员[...new Set(array)] 注意！向Set加入值的时候，不会发生类型转换，所以5和”5”是两个不同的值。Set内部判断两个值是否不同，使用的算法叫做“Same-value equality”，它类似于精确相等运算符（===），主要的区别是NaN等于自身，而精确相等运算符认为NaN不等于自身。123456let set = new Set();let a = NaN;let b = NaN;set.add(a);set.add(b);set // Set &#123;NaN&#125; 上例中向Set实例添加了两个NaN，但是只能加入一个。这表明，在Set内部，两个NaN是相等。Set实例有自己属性和方法Set.prototype.constructor:构造函数，默认就是Set函数。Set.prototype.size:返回Set实例的成员总数。Set实例的方法分为两大类：操作方法（用于操作数据）和遍历方法（用于遍历成员)add(value):添加某个值，返回Set结构本身。delete(value):添加某个值，返回Set结构本身。has(value):返回一个布尔值，表示该值是否为Set的成员。clear():清除所有成员，没有返回值。123456789s.add(1).add(2).add(2);// 注意2被加入了两次s.size // 2s.has(1) // trues.has(2) // trues.has(3) // falses.delete(2);s.has(2) // false Array.from方法可以将Set结构转为数组。12var items = new Set([1, 2, 3, 4, 5]);var array = Array.from(items); 由此就有了数组去重的方法1234function dedupe(array) &#123; return Array.from(new Set(array));&#125;dedupe([1, 1, 2, 3]) // [1, 2, 3] Set结构的实例有四个遍历方法，可以用于遍历成员。keys():返回键名的遍历器values():返回键值的遍历器entries():返回键值对的遍历器forEach():使用回调函数遍历每个成员特别指出的是，Set的遍历顺序就是插入顺序。这个特性有时非常有用，比如使用Set保存一个回调函数列表，调用时就能保证按照添加顺序调用。keys方法、values方法、entries方法返回的都是遍历器对象。由于 Set 结构没有键名，只有键值（或者说键名和键值是同一个值），所以keys方法和values方法的行为完全一致。12345678910111213141516171819let set = new Set(['red', 'green', 'blue']);for (let item of set.keys()) &#123; console.log(item);&#125;// red// green// bluefor (let item of set.values()) &#123; console.log(item);&#125;// red// green// bluefor (let item of set.entries()) &#123; console.log(item);&#125;// ["red", "red"]// ["green", "green"]// ["blue", "blue"] 上例中，entries方法返回的遍历器，同时包括键名和键值，所以每次输出一个数组，它的两个成员完全相等。Set结构的实例默认可遍历，它的默认遍历器生成函数就是它的values方法。意味着我们可以使用for…of循环遍历Set。1234567let set = new Set(['red', 'green', 'blue']);for (let x of set) &#123; console.log(x);&#125;// red// green// blue 扩展运算符（…）内部使用for…of循环，所以也可以用于Set结构。123let set = new Set(['red', 'green', 'blue']);let arr = [...set];// ['red', 'green', 'blue'] 扩展运算符和Set结构相结合，就可以去除数组的重复成员。123let arr = [3, 5, 2, 2, 5, 5];let unique = [...new Set(arr)];// [3, 5, 2] 数组的map和filter方法也可以用于Set123456let set = new Set([1, 2, 3]);set = new Set([...set].map(x =&gt; x * 2));// 返回Set结构：&#123;2, 4, 6&#125;let set = new Set([1, 2, 3, 4, 5]);set = new Set([...set].filter(x =&gt; (x % 2) == 0));// 返回Set结构：&#123;2, 4&#125; WeakSet结构与Set类似，也是不重复的值的集合。但是，它与Set有两个区别。首先，WeakSet的成员只能是对象，而不能是其他类型的值。其次，WeakSet中的对象都是弱引用，即垃圾回收机制不考虑WeakSet对该对象的引用，也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于WeakSet之中。这个特点意味着，无法引用WeakSet的成员，因此WeakSet是不可遍历的。WeakSet是一个构造函数，可以使用new命令，创建WeakSet数据结构。作为构造函数，WeakSet可以接受一个数组或类似数组的对象作为参数。该数组的所有成员，都会自动成为WeakSet实例对象的成员。12var a = [[1,2], [3,4]];var ws = new WeakSet(a); WeakSet没有size属性，没有办法遍历它的成员,因为成员都是弱引用，随时可能消失，遍历机制无法保证成员的存在，很可能刚刚遍历结束，成员就取不到了。WeakSet的一个用处，是储存DOM节点，而不用担心这些节点从文档移除时，会引发内存泄漏。1234567891011const foos = new WeakSet()class Foo &#123; constructor() &#123; foos.add(this) &#125; method () &#123; if (!foos.has(this)) &#123; throw new TypeError('Foo.prototype.method 只能在Foo的实例上调用！'); &#125; &#125;&#125; 上面代码保证了Foo的实例方法，只能在Foo的实例上调用。这里使用WeakSet的好处是，foos对实例的引用，不会被计入内存回收机制，所以删除实例的时候，不用考虑foos，也不会出现内存泄漏。 MapMap结构的目的和基本用法Map类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。也就是说，Object结构提供了“字符串—值”的对应，Map结构提供了“值—值”的对应，是一种更完善的Hash结构实现。如果你需要“键值对”的数据结构，Map比Object更合适。1234567var m = new Map();var o = &#123;p: 'Hello World'&#125;;m.set(o, 'content')m.get(o) // "content"m.has(o) // truem.delete(o) // truem.has(o) // false 上面代码使用set方法，将对象o当作m的一个键，然后又使用get方法读取这个键，接着使用delete方法删除了这个键。Map也可以接受一个数组作为参数。该数组的成员是一个个表示键值对的数组。123456789var map = new Map([ ['name', '张三'], ['title', 'Author']]);map.size // 2map.has('name') // truemap.get('name') // "张三"map.has('title') // truemap.get('title') // "Author" 上面代码在新建Map实例时，就指定了两个键name和title。注意字符串true和布尔值true是两个不同的键。123456var m = new Map([ [true, 'foo'], ['true', 'bar']]);m.get(true) // 'foo'm.get('true') // 'bar' 如果对同一个键多次赋值，后面的值将覆盖前面的值。12345let map = new Map();map.set(1, 'aaa').set(1, 'bbb');map.get(1) // "bbb" Map的键是跟内存地址绑定的，只要内存地址不一样，就视为两个键。12345678var map = new Map();var k1 = ['a'];var k2 = ['a'];map.set(k1, 111).set(k2, 222);map.get(k1) // 111map.get(k2) // 222 实例的属性和操作方法size属性返回Map结构的成员总数1234let map = new Map();map.set('foo', true);map.set('bar', false);map.size // 2 Map的set方法设置key所对应的键值，然后返回整个Map结构。如果key已经有值，则键值会被更新，否则就新生成该键。set方法返回的是Map本身，因此可以采用链式写法。1234let map = new Map() .set(1, 'a') .set(2, 'b') .set(3, 'c'); get方法读取key对应的键值，如果找不到key，返回undefined。has方法返回一个布尔值，表示某个键是否在Map数据结构中。delete方法删除某个键，返回true。如果删除失败，返回false。clear方法清除所有成员，没有返回值。 遍历方法keys():返回键名的遍历器values():返回键值的遍历器entries():返回所有成员的遍历器forEach():遍历Map的所有成员注意！Map的遍历顺序就是插入顺序Map结构转为数组结构，比较快速的方法是结合使用扩展运算符（…）。12345678910111213let map = new Map([ [1, 'one'], [2, 'two'], [3, 'three'],]);[...map.keys()]// [1, 2, 3][...map.values()]// ['one', 'two', 'three'][...map.entries()]// [[1,'one'], [2, 'two'], [3, 'three']][...map]// [[1,'one'], [2, 'two'], [3, 'three']] 结合数组的map方法、filter方法，可以实现Map的遍历和过滤（Map本身没有map和filter方法）。123456789101112let map0 = new Map() .set(1, 'a') .set(2, 'b') .set(3, 'c');let map1 = new Map( [...map0].filter(([k, v]) =&gt; k &lt; 3));// 产生Map结构 &#123;1 =&gt; 'a', 2 =&gt; 'b'&#125;let map2 = new Map( [...map0].map(([k, v]) =&gt; [k * 2, '_' + v]) );// 产生Map结构 &#123;2 =&gt; '_a', 4 =&gt; '_b', 6 =&gt; '_c'&#125; 与其他数据结构的互相转换Map转为数组最方便的方法，就是使用扩展运算符（…）。123let myMap = new Map().set(true, 7).set(&#123;foo: 3&#125;, ['abc']);[...myMap]// [ [ true, 7 ], [ &#123; foo: 3 &#125;, [ 'abc' ] ] ] 将数组转入Map构造函数，就可以转为Map。12new Map([[true, 7], [&#123;foo: 3&#125;, ['abc']]])// Map &#123;true =&gt; 7, Object &#123;foo: 3&#125; =&gt; ['abc']&#125; 如果所有Map的键都是字符串，它可以转为对象。12345678910function strMapToObj(strMap) &#123; let obj = Object.create(null); for (let [k,v] of strMap) &#123; obj[k] = v; &#125; return obj;&#125;let myMap = new Map().set('yes', true).set('no', false);strMapToObj(myMap)// &#123; yes: true, no: false &#125; Map转为JSON，分两种情况，一种情况是，Map的键名都是字符串，这时可以选择转为对象JSON。1234567function strMapToJson(strMap) &#123; return JSON.stringify(strMapToObj(strMap));&#125;//先转化为对象再使用JSON.stringify方法let myMap = new Map().set('yes', true).set('no', false);strMapToJson(myMap)// '&#123;"yes":true,"no":false&#125;' 另一种情况是，Map的键名有非字符串，这时可以选择转为数组JSON。123456function mapToArrayJson(map) &#123; return JSON.stringify([...map]);&#125;let myMap = new Map().set(true, 7).set(&#123;foo: 3&#125;, ['abc']);mapToArrayJson(myMap)// '[[true,7],[&#123;"foo":3&#125;,["abc"]]]']]></content>
    </entry>

    
    <entry>
      <title><![CDATA[es6的新特性(二)]]></title>
      <url>%2Fposts%2F17229%2F</url>
      <content type="text"><![CDATA[变量的解构赋值数组的解构赋值在es5中，为变量赋值，只能直接指定值，如下所示123var a = 1;var b = 2;var c = 3; es6中可以这样写1var [a, b, c] = [1, 2, 3]; 上面代码中，数组对应位置，为变量赋值。只要等号两边的模式相同，左边的变量就会被赋予对应的值。例如可以嵌套数组解构1234let [foo, [[bar], baz]] = [1, [[2], 3]];foo // 1bar // 2baz // 3 根据数组的属性还可以这样写12let [ , , z] = ["html", "css", "js"];z // "js" 当然如果解构不成功，变量的值就是undefined123var [foo] = [];var [bar, foo] = [1];foo //undefined 上面是等号右边值数量小于左边，看一下另一种情况123let [x, y] = [1, 2, 3];x // 1y // 2 如上所示，这种情况下是可以解构成功，在es6中被称作不完全解构如果等号的右边不是数组将会报错1234567// 报错let [foo] = 1;let [foo] = false;let [foo] = NaN;let [foo] = undefined;let [foo] = null;let [foo] = &#123;&#125;; 解构赋值不仅适用于var命令，也适用于es6新加的let和const命令。解构赋值允许指定默认值。12let [ x='html'] = [];x // html 对象的解构赋值对象的解构与数组有不同，数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。12345var &#123; bar, foo &#125; = &#123; foo: "aaa", bar: "bbb" &#125;;foo // "aaa"bar // "bbb"var &#123; baz &#125; = &#123; foo: "aaa", bar: "bbb" &#125;;baz // undefined 上例中等号左边的两个变量的次序，与等号右边两个同名属性的次序不一致，但是对取值完全没有影响。第二个例子的变量没有对应的同名属性，导致取不到值，最后等于undefined。如果变量名与属性名不一致，必须写成下面这样。1234let obj = &#123; first: 'hello', last: 'world' &#125;;let &#123; first: f, last: l &#125; = obj;f // 'hello'l // 'world' 在es6的对象解构赋值中，变量的声明和赋值是一体的。对于let和const来说，变量不能重新声明，所以一旦赋值的变量以前声明过，就会报错。12345let foo;let &#123;foo&#125; = &#123;foo: 1&#125;; // SyntaxError: Duplicate declaration "foo"let baz;let &#123;bar: baz&#125; = &#123;bar: 1&#125;; // SyntaxError: Duplicate declaration "baz" 上例中，解构赋值的变量都会重新声明，所以报错了。不过，因为var命令允许重新声明，所以这个错误只会在使用let和const命令时出现。如果没有第二个let命令，上面的代码就不会报错。注意，用这种方式必须加上小括号，因为解析器会将起首的大括号，理解成一个代码块，而不是赋值语句。如下所示12345let foo;(&#123;foo&#125; = &#123;foo: 1&#125;); // 成功let baz;(&#123;bar: baz&#125; = &#123;bar: 1&#125;); // 成功 和数组一样，解构也可以用于嵌套结构的对象。12345678let obj = &#123;&#125;;let arr = [];(&#123; foo: obj.prop, bar: arr[0] &#125; = &#123; foo: 123, bar: true &#125;);obj // &#123;prop:123&#125;arr // [true]y // "World" 对象的解构也可以指定默认值。123456var &#123;x = 3&#125; = &#123;&#125;;x // 3var &#123;x, y = 5&#125; = &#123;x: 1&#125;;x // 1y // 5 字符串的解构赋值字符串也可以解构赋值。这是因为，字符串被转换成了一个类似数组的对象。123456const [a, b, c, d, e] = 'hello';a // "h"b // "e"c // "l"d // "l"e // "o" 函数参数的解构赋值1234function add([x, y])&#123; return x + y;&#125;add([1, 2]); // 3 上例中函数add的参数是一个数组，传参时数组参数就被解构成变量x和y。函数参数的解构也可以使用默认值。12345678function move(&#123;x = 0, y = 0&#125; = &#123;&#125;) &#123; return [x, y];&#125;move(&#123;x: 3, y: 8&#125;); // [3, 8]move(&#123;x: 3&#125;); // [3, 0]move(&#123;&#125;); // [0, 0]move(); // [0, 0] 解构赋值的用途交换变量的值1[x, y] = [y, x]; 从函数返回多个值函数只能返回一个值，如果要返回多个值，只能将它们放在数组或对象里返回。有了解构赋值，取出这些值就非常方便。1234567891011121314function box() &#123; return [1, 2, 3];&#125;var [a, b, c] = box();// 返回一个对象function box() &#123; return &#123; foo: 1, bar: 2 &#125;;&#125;var &#123; foo, bar &#125; = box(); 提取JSON数据12345678910var jsonData = &#123; id: 42, status: "OK", data: [867, 5309]&#125;;let &#123; id, status, data: number &#125; = jsonData;console.log(id, status, number);// 42, "OK", [867, 5309]]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[vue学习(一)]]></title>
      <url>%2Fposts%2F49667%2F</url>
      <content type="text"><![CDATA[之前电脑坏了等了好久才修好，拿回来网又出问题了，打了客服电话，慢吞吞才来，于是好久都没更新博客了(我才不会说是懒癌发作)，但是这期间也没闲着，毕竟在这个别人比你富有还比你努力的时代，我这个学渣必须更得努力才是。好罢进入学习中吧。 vue.js是什么vue.js在2016年真是特别的火，基本我加的前端群都差不多有vue.js的讨论，那么vue.js是什么呢，看下vue.js 2.0文档里的说法吧！Vue.js（读音 /vjuː/, 类似于 view） 是一套构建用户界面的渐进式框架。与其他重量级框架不同的是，Vue 采用自底向上增量开发的设计。Vue 的核心库只关注视图层，并且非常容易学习，非常容易与其它库或已有项目整合。另一方面，Vue 完全有能力驱动采用单文件组件和 Vue 生态系统支持的库开发的复杂单页应用。初看这段话初读完全有点晕，看下例子123456789101112131415161718192021&lt;!doctype html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;vue&lt;/title&gt; &lt;script src="http://cdnjs.cloudflare.com/ajax/libs/vue/2.1.3/vue.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="app"&gt; &#123;&#123; message &#125;&#125; &lt;/div&gt;&lt;/body&gt;&lt;script&gt;var app = new Vue(&#123; el: '#app', data: &#123; message: 'Hello 羊羊羊!' &#125;&#125;)&lt;/script&gt;&lt;/html&gt; 运行这段代码，会显示Hello羊羊羊,script里面的message,传入到了div里面，当更改message的值时，页面也会相应改变，再回忆下jQuery，如果jQuery要达到这样的效果就必须先获得message的dom，然后用text()方法进行更改，而vue.js则完全不用这么复杂，使用vue.js后，数据和 DOM 已经被绑定在一起，所有的元素都是响应式的，所以综合来说 vue.js是数据驱动，当数据变化时dom会自动发生更改，不再需要繁杂的dom操作。 vue.js的安装cdn可以直接像引用js文件一样引入1&lt;script src="https://unpkg.com/vue/dist/vue.js"&gt;&lt;/script&gt; 学习环境下这种方式比较好，可根据文档专注于vue.js本身，而不用考虑配置等一些列问题 npm用node.js包管理工具进行安装1$ npm install vue Vue.js 提供一个官方命令行工具，具体操作如下1234567# 全局安装 vue-cli$ npm install --global vue-cli# 创建一个基于 webpack 模板的新项目$ vue init webpack my-project# 安装依赖$ cd my-project$ npm install 完毕之后在进行$ npm run dev命令，打开浏览器输入localhost:8080即可]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[es6的新特性(一)]]></title>
      <url>%2Fposts%2F33769%2F</url>
      <content type="text"><![CDATA[之前已经看了一遍es6的文档,因为之前学习过其它语言,发现es6的新特性好多都是跟其它语言相似的,例如class,const,然后就没怎么太认真看,但在实际使用中却发现很多东西并不是很熟悉,于是只能认认真真的从头来过,这也让我得到了一个印象深刻的教训,不要凭自己的主观去想当然,在技术的世界里一定要严谨再严谨,好了闲话少述,进入正题。 let基本用法 let和const是es6声明变量的新方法,众所周知,es5申明变量是通过var,var的一大缺点就是没有局部作用域,经常会出现意想不到的错误,es6就顺势推出了let.1234567 &#123; let a = 10; var b = 1; &#125;a // ReferenceError: a is not defined.b // 1 上面代码在代码块之中，分别用let和var声明了两个变量。然后在代码块之外调用这两个变量，结果let声明的变量报错，var声明的变量返回了正确的值。这表明，let声明的变量只在它所在的代码块有效。 再看一个例子1234567var a = [];for (var i = 0; i &lt; 10; i++) &#123; a[i] = function () &#123; console.log(i); &#125;;&#125;a[6](); // 10 这个例子中变量i是var声明的，在全局范围内都有效。所以每一次循环，新的i值都会覆盖旧值，导致最后输出的是最后一轮的i的值,也就是10。 将var改成let1234567var a = [];for (let i = 0; i &lt; 10; i++) &#123; a[i] = function () &#123; console.log(i); &#125;;&#125;a[6](); // 6 上面代码中，变量i是let声明的，当前的i只在本轮循环有效，所以每一次循环的i其实都是一个新的变量，所以最后输出的是6。 暂时性死区块级作用域内存在let命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。12345var tmp = 123;if (true) &#123; tmp = 'abc'; // ReferenceError let tmp;&#125; 上面代码中，存在全局变量tmp，但是块级作用域内let又声明了一个局部变量tmp，导致后者绑定这个块级作用域，所以在let声明变量前，对tmp赋值会报错.在es6中如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称TDZ）。ES6规定暂时性死区和let、const语句不出现变量提升，主要是为了减少运行时错误，防止在变量声明前就使用这个变量，从而导致意料之外的行为。 不允许重复声明let不允许在相同作用域内，重复声明同一个变量。1234567891011// 报错function () &#123; let a = 10; var a = 1;&#125;// 报错function () &#123; let a = 10; let a = 1;&#125; do表达式1234&#123; let t = f(); t = t * t + 1;&#125; 上面代码中，块级作用域将两个语句封装在一起。但是，在块级作用域以外，没有办法得到t的值，因为块级作用域不返回值，除非t是全局变量。那么怎么得到块级作用域的返回值呢?办法就是在块级作用域之前加上do，使它变为do表达式。代码如下:1234&#123; let t = f(); t = t * t + 1;&#125; constconst声明一个只读的常量。一旦声明，常量的值就不能改变。12345const PI = 3.1415;PI // 3.1415PI = 3;// TypeError: Assignment to constant variable. 上面代码表明改变常量的值会报错。const声明的变量不得改变值，这意味着，const一旦声明变量，就必须立即初始化，不能留到以后赋值。同时const的作用域与let命令相同：只在声明所在的块级作用域内有效，声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用,也一样不可重复声明。对于复合类型的变量，变量名不指向数据，而是指向数据所在的地址。const命令只是保证变量名指向的地址不变，并不保证该地址的数据不变，所以将一个对象声明为常量必须非常小心。1234567const foo = &#123;&#125;;foo.prop = 123;foo.prop// 123foo = &#123;&#125;; // TypeError: "foo" is read-only 这段代码中常量foo储存的是一个地址，这个地址指向一个对象。不可变的只是这个地址，即不能把foo指向另一个地址，但对象本身是可变的，所以依然可以为其添加新属性。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[终于搭好了自己的个人博客]]></title>
      <url>%2Fposts%2F53204%2F</url>
      <content type="text"><![CDATA[是的,终于搭建好了自己的个人博客.之前看完node.js和express框架文档后,就想着尝试用express做一个自己的博客,一方面可实践坐下项目,另一方面没事写写文章,这可是装逼好能手啊!可是作为懒癌晚期患者,断断续续写了一两个月,也只写了一小部分,但即便如此也死了很多脑细胞,当然也学到很多的知识,正当我还想继续发扬一懒到底精神的时候,某天在技术群看到hexo+github快速搭建博客,关键的是不用买服务器,good!顿时起了兴趣,看了教程就开始入手,不到一个小时主体框架就出来了,心情很鸡冻啊有木有,然后在接下来几天里只要有空就会研究如何去美化这个博客,挑了好久最终挑选了next这个主题,一个个小功能去实现,在实现过程中也发现了很多很好玩的东西,例如:各种以前没听说的第三方好用的服务,也让我收获颇丰,当然总体来说这个博客搭建并没有其他太多的技术含量,还有很多地方也需要改进,哈哈希望能发现更多好玩的东西往里面塞吧!]]></content>
    </entry>

    
  
  
</search>
