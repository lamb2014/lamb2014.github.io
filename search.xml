<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[vue学习(一)]]></title>
      <url>%2Fposts%2F49667%2F</url>
      <content type="text"><![CDATA[之前电脑坏了等了好久才修好，拿回来网又出问题了，打了客服电话，慢吞吞才来，于是好久都没更新博客了(我才不会说是懒癌发作)，但是这期间也没闲着，毕竟在这个别人比你富有还比你努力的时代，我这个学渣必须更得努力才是。好罢进入学习中吧。 vue.js是什么vue.js在2016年真是特别的火，基本我加的前端群都差不多有vue.js的讨论，那么vue.js是什么呢，看下vue.js 2.0文档里的说法吧！Vue.js（读音 /vjuː/, 类似于 view） 是一套构建用户界面的渐进式框架。与其他重量级框架不同的是，Vue 采用自底向上增量开发的设计。Vue 的核心库只关注视图层，并且非常容易学习，非常容易与其它库或已有项目整合。另一方面，Vue 完全有能力驱动采用单文件组件和 Vue 生态系统支持的库开发的复杂单页应用。初看这段话初读完全有点晕，看下例子123456789101112131415161718192021&lt;!doctype html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;vue&lt;/title&gt; &lt;script src="http://cdnjs.cloudflare.com/ajax/libs/vue/2.1.3/vue.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="app"&gt; &#123;&#123; message &#125;&#125; &lt;/div&gt;&lt;/body&gt;&lt;script&gt;var app = new Vue(&#123; el: '#app', data: &#123; message: 'Hello 羊羊羊!' &#125;&#125;)&lt;/script&gt;&lt;/html&gt; 运行这段代码，会显示Hello羊羊羊,script里面的message,传入到了div里面，当更改message的值时，页面也会相应改变，再回忆下jQuery，如果jQuery要达到这样的效果就必须先获得message的dom，然后用text()方法进行更改，而vue.js则完全不用这么复杂，使用vue.js后，数据和 DOM 已经被绑定在一起，所有的元素都是响应式的，所以综合来说 vue.js是数据驱动，当数据变化时dom会自动发生更改，不再需要繁杂的dom操作。 vue.js的安装cdn可以直接像引用js文件一样引入1&lt;script src="https://unpkg.com/vue/dist/vue.js"&gt;&lt;/script&gt; 学习环境下这种方式比较好，可根据文档专注于vue.js本身，而不用考虑配置等一些列问题 npm用node.js包管理工具进行安装1$ npm install vue Vue.js 提供一个官方命令行工具，具体操作如下1234567# 全局安装 vue-cli$ npm install --global vue-cli# 创建一个基于 webpack 模板的新项目$ vue init webpack my-project# 安装依赖$ cd my-project$ npm install 完毕之后在进行$ npm run dev命令，打开浏览器输入localhost:8080即可]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[es6的新特性(一)]]></title>
      <url>%2Fposts%2F33769%2F</url>
      <content type="text"><![CDATA[之前已经看了一遍es6的文档,因为之前学习过其它语言,发现es6的新特性好多都是跟其它语言相似的,例如class,const,然后就没怎么太认真看,但在实际使用中却发现很多东西并不是很熟悉,于是只能认认真真的从头来过,这也让我得到了一个印象深刻的教训,不要凭自己的主观去想当然,在技术的世界里一定要严谨再严谨,好了闲话少述,进入正题。 let基本用法 let和const是es6声明变量的新方法,众所周知,es5申明变量是通过var,var的一大缺点就是没有局部作用域,经常会出现意想不到的错误,es6就顺势推出了let.1234567 &#123; let a = 10; var b = 1; &#125;a // ReferenceError: a is not defined.b // 1 上面代码在代码块之中，分别用let和var声明了两个变量。然后在代码块之外调用这两个变量，结果let声明的变量报错，var声明的变量返回了正确的值。这表明，let声明的变量只在它所在的代码块有效。 再看一个例子1234567var a = [];for (var i = 0; i &lt; 10; i++) &#123; a[i] = function () &#123; console.log(i); &#125;;&#125;a[6](); // 10 这个例子中变量i是var声明的，在全局范围内都有效。所以每一次循环，新的i值都会覆盖旧值，导致最后输出的是最后一轮的i的值,也就是10。 将var改成let1234567var a = [];for (let i = 0; i &lt; 10; i++) &#123; a[i] = function () &#123; console.log(i); &#125;;&#125;a[6](); // 6 上面代码中，变量i是let声明的，当前的i只在本轮循环有效，所以每一次循环的i其实都是一个新的变量，所以最后输出的是6。 暂时性死区块级作用域内存在let命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。12345var tmp = 123;if (true) &#123; tmp = 'abc'; // ReferenceError let tmp;&#125; 上面代码中，存在全局变量tmp，但是块级作用域内let又声明了一个局部变量tmp，导致后者绑定这个块级作用域，所以在let声明变量前，对tmp赋值会报错.在es6中如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称TDZ）。ES6规定暂时性死区和let、const语句不出现变量提升，主要是为了减少运行时错误，防止在变量声明前就使用这个变量，从而导致意料之外的行为。 不允许重复声明let不允许在相同作用域内，重复声明同一个变量。1234567891011// 报错function () &#123; let a = 10; var a = 1;&#125;// 报错function () &#123; let a = 10; let a = 1;&#125; do表达式1234&#123; let t = f(); t = t * t + 1;&#125; 上面代码中，块级作用域将两个语句封装在一起。但是，在块级作用域以外，没有办法得到t的值，因为块级作用域不返回值，除非t是全局变量。那么怎么得到块级作用域的返回值呢?办法就是在块级作用域之前加上do，使它变为do表达式。代码如下:1234&#123; let t = f(); t = t * t + 1;&#125; constconst声明一个只读的常量。一旦声明，常量的值就不能改变。12345const PI = 3.1415;PI // 3.1415PI = 3;// TypeError: Assignment to constant variable. 上面代码表明改变常量的值会报错。const声明的变量不得改变值，这意味着，const一旦声明变量，就必须立即初始化，不能留到以后赋值。同时const的作用域与let命令相同：只在声明所在的块级作用域内有效，声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用,也一样不可重复声明。对于复合类型的变量，变量名不指向数据，而是指向数据所在的地址。const命令只是保证变量名指向的地址不变，并不保证该地址的数据不变，所以将一个对象声明为常量必须非常小心。1234567const foo = &#123;&#125;;foo.prop = 123;foo.prop// 123foo = &#123;&#125;; // TypeError: "foo" is read-only 这段代码中常量foo储存的是一个地址，这个地址指向一个对象。不可变的只是这个地址，即不能把foo指向另一个地址，但对象本身是可变的，所以依然可以为其添加新属性。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[终于搭好了自己的个人博客]]></title>
      <url>%2Fposts%2F53204%2F</url>
      <content type="text"><![CDATA[是的,终于搭建好了自己的个人博客.之前看完node.js和express框架文档后,就想着尝试用express做一个自己的博客,一方面可实践坐下项目,另一方面没事写写文章,这可是装逼好能手啊!可是作为懒癌晚期患者,断断续续写了一两个月,也只写了一小部分,但即便如此也死了很多脑细胞,当然也学到很多的知识,正当我还想继续发扬一懒到底精神的时候,某天在技术群看到hexo+github快速搭建博客,关键的是不用买服务器,good!顿时起了兴趣,看了教程就开始入手,不到一个小时主体框架就出来了,心情很鸡冻啊有木有,然后在接下来几天里只要有空就会研究如何去美化这个博客,挑了好久最终挑选了next这个主题,一个个小功能去实现,在实现过程中也发现了很多很好玩的东西,例如:各种以前没听说的第三方好用的服务,也让我收获颇丰,当然总体来说这个博客搭建并没有其他太多的技术含量,还有很多地方也需要改进,哈哈希望能发现更多好玩的东西往里面塞吧!]]></content>
    </entry>

    
  
  
</search>
